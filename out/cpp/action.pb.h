// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: action.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_action_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_action_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_action_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_action_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_action_2eproto;
namespace action {
class Connect;
struct ConnectDefaultTypeInternal;
extern ConnectDefaultTypeInternal _Connect_default_instance_;
class Device;
struct DeviceDefaultTypeInternal;
extern DeviceDefaultTypeInternal _Device_default_instance_;
class DeviceRequest;
struct DeviceRequestDefaultTypeInternal;
extern DeviceRequestDefaultTypeInternal _DeviceRequest_default_instance_;
class DeviceResponse;
struct DeviceResponseDefaultTypeInternal;
extern DeviceResponseDefaultTypeInternal _DeviceResponse_default_instance_;
class GetAttr;
struct GetAttrDefaultTypeInternal;
extern GetAttrDefaultTypeInternal _GetAttr_default_instance_;
class InteractionRequest;
struct InteractionRequestDefaultTypeInternal;
extern InteractionRequestDefaultTypeInternal _InteractionRequest_default_instance_;
class InteractionResponse;
struct InteractionResponseDefaultTypeInternal;
extern InteractionResponseDefaultTypeInternal _InteractionResponse_default_instance_;
class LogData;
struct LogDataDefaultTypeInternal;
extern LogDataDefaultTypeInternal _LogData_default_instance_;
class MoveElement;
struct MoveElementDefaultTypeInternal;
extern MoveElementDefaultTypeInternal _MoveElement_default_instance_;
class MoveOffset;
struct MoveOffsetDefaultTypeInternal;
extern MoveOffsetDefaultTypeInternal _MoveOffset_default_instance_;
class PerformanceData;
struct PerformanceDataDefaultTypeInternal;
extern PerformanceDataDefaultTypeInternal _PerformanceData_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class Screenshot;
struct ScreenshotDefaultTypeInternal;
extern ScreenshotDefaultTypeInternal _Screenshot_default_instance_;
class SetAttr;
struct SetAttrDefaultTypeInternal;
extern SetAttrDefaultTypeInternal _SetAttr_default_instance_;
class Test;
struct TestDefaultTypeInternal;
extern TestDefaultTypeInternal _Test_default_instance_;
class TestDetails;
struct TestDetailsDefaultTypeInternal;
extern TestDetailsDefaultTypeInternal _TestDetails_default_instance_;
class Test_ParameterEntry_DoNotUse;
struct Test_ParameterEntry_DoNotUseDefaultTypeInternal;
extern Test_ParameterEntry_DoNotUseDefaultTypeInternal _Test_ParameterEntry_DoNotUse_default_instance_;
class Tests;
struct TestsDefaultTypeInternal;
extern TestsDefaultTypeInternal _Tests_default_instance_;
class Touch;
struct TouchDefaultTypeInternal;
extern TouchDefaultTypeInternal _Touch_default_instance_;
}  // namespace action
PROTOBUF_NAMESPACE_OPEN
template<> ::action::Connect* Arena::CreateMaybeMessage<::action::Connect>(Arena*);
template<> ::action::Device* Arena::CreateMaybeMessage<::action::Device>(Arena*);
template<> ::action::DeviceRequest* Arena::CreateMaybeMessage<::action::DeviceRequest>(Arena*);
template<> ::action::DeviceResponse* Arena::CreateMaybeMessage<::action::DeviceResponse>(Arena*);
template<> ::action::GetAttr* Arena::CreateMaybeMessage<::action::GetAttr>(Arena*);
template<> ::action::InteractionRequest* Arena::CreateMaybeMessage<::action::InteractionRequest>(Arena*);
template<> ::action::InteractionResponse* Arena::CreateMaybeMessage<::action::InteractionResponse>(Arena*);
template<> ::action::LogData* Arena::CreateMaybeMessage<::action::LogData>(Arena*);
template<> ::action::MoveElement* Arena::CreateMaybeMessage<::action::MoveElement>(Arena*);
template<> ::action::MoveOffset* Arena::CreateMaybeMessage<::action::MoveOffset>(Arena*);
template<> ::action::PerformanceData* Arena::CreateMaybeMessage<::action::PerformanceData>(Arena*);
template<> ::action::Request* Arena::CreateMaybeMessage<::action::Request>(Arena*);
template<> ::action::Response* Arena::CreateMaybeMessage<::action::Response>(Arena*);
template<> ::action::Screenshot* Arena::CreateMaybeMessage<::action::Screenshot>(Arena*);
template<> ::action::SetAttr* Arena::CreateMaybeMessage<::action::SetAttr>(Arena*);
template<> ::action::Test* Arena::CreateMaybeMessage<::action::Test>(Arena*);
template<> ::action::TestDetails* Arena::CreateMaybeMessage<::action::TestDetails>(Arena*);
template<> ::action::Test_ParameterEntry_DoNotUse* Arena::CreateMaybeMessage<::action::Test_ParameterEntry_DoNotUse>(Arena*);
template<> ::action::Tests* Arena::CreateMaybeMessage<::action::Tests>(Arena*);
template<> ::action::Touch* Arena::CreateMaybeMessage<::action::Touch>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace action {

enum DeviceInteractionType : int {
  LockDevice = 0,
  UnlockDevice = 1,
  GetDeviceState = 2,
  IsAppInstalled = 3,
  InstallApp = 4,
  UninstallApp = 5,
  StartApp = 6,
  StopApp = 7,
  IsAppConnected = 8,
  StartRecording = 9,
  StopRecording = 10,
  HasFeature = 11,
  ExecuteFeature = 12,
  GetScreenShot = 13,
  DeviceInteractionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DeviceInteractionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DeviceInteractionType_IsValid(int value);
constexpr DeviceInteractionType DeviceInteractionType_MIN = LockDevice;
constexpr DeviceInteractionType DeviceInteractionType_MAX = GetScreenShot;
constexpr int DeviceInteractionType_ARRAYSIZE = DeviceInteractionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceInteractionType_descriptor();
template<typename T>
inline const std::string& DeviceInteractionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceInteractionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceInteractionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceInteractionType_descriptor(), enum_t_value);
}
inline bool DeviceInteractionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceInteractionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceInteractionType>(
    DeviceInteractionType_descriptor(), name, value);
}
enum ActionType : int {
  Custom = 0,
  GetSceneGraph = 1,
  ElementIsDisplayed = 2,
  ElementSetValue = 3,
  ElementGetValue = 4,
  Move = 5,
  TouchDown = 6,
  TouchMove = 7,
  TouchUp = 8,
  DragAndDrop = 9,
  LongTouch = 10,
  ElementTouch = 11,
  GetScreenshot = 12,
  GetTests = 13,
  ExecuteTest = 14,
  ExecutionResult = 15,
  Log = 16,
  UnityReset = 17,
  Performance = 18,
  NativeScript = 19,
  ActionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActionType_IsValid(int value);
constexpr ActionType ActionType_MIN = Custom;
constexpr ActionType ActionType_MAX = NativeScript;
constexpr int ActionType_ARRAYSIZE = ActionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActionType_descriptor();
template<typename T>
inline const std::string& ActionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActionType_descriptor(), enum_t_value);
}
inline bool ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActionType>(
    ActionType_descriptor(), name, value);
}
enum LogType : int {
  DeviceLog = 0,
  StepLog = 1,
  StatusLog = 2,
  CheckpointLog = 3,
  PerformanceLog = 4,
  LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogType_IsValid(int value);
constexpr LogType LogType_MIN = DeviceLog;
constexpr LogType LogType_MAX = PerformanceLog;
constexpr int LogType_ARRAYSIZE = LogType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogType_descriptor();
template<typename T>
inline const std::string& LogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogType_descriptor(), enum_t_value);
}
inline bool LogType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogType>(
    LogType_descriptor(), name, value);
}
enum LogLevel : int {
  Debug = 0,
  Info = 1,
  Warning = 2,
  Error = 3,
  Exception = 4,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = Debug;
constexpr LogLevel LogLevel_MAX = Exception;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum ContentType : int {
  Flatbuffer = 0,
  Json = 1,
  Xml = 2,
  ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ContentType_IsValid(int value);
constexpr ContentType ContentType_MIN = Flatbuffer;
constexpr ContentType ContentType_MAX = Xml;
constexpr int ContentType_ARRAYSIZE = ContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ContentType_descriptor();
template<typename T>
inline const std::string& ContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ContentType_descriptor(), enum_t_value);
}
inline bool ContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ContentType>(
    ContentType_descriptor(), name, value);
}
enum AppType : int {
  Cocos = 0,
  Unity = 1,
  AppType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AppType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AppType_IsValid(int value);
constexpr AppType AppType_MIN = Cocos;
constexpr AppType AppType_MAX = Unity;
constexpr int AppType_ARRAYSIZE = AppType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppType_descriptor();
template<typename T>
inline const std::string& AppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppType_descriptor(), enum_t_value);
}
inline bool AppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppType>(
    AppType_descriptor(), name, value);
}
// ===================================================================

class Device final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Device) */ {
 public:
  inline Device() : Device(nullptr) {}
  ~Device() override;
  explicit constexpr Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Device(const Device& from);
  Device(Device&& from) noexcept
    : Device() {
    *this = ::std::move(from);
  }

  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Device& operator=(Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Device* internal_default_instance() {
    return reinterpret_cast<const Device*>(
               &_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Device& a, Device& b) {
    a.Swap(&b);
  }
  inline void Swap(Device* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Device>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Device& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Device& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Device* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Device";
  }
  protected:
  explicit Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManagerFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kOperationSystemFieldNumber = 4,
    kSupportedArchitecturesFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  // string manager = 1;
  void clear_manager();
  const std::string& manager() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_manager(ArgT0&& arg0, ArgT... args);
  std::string* mutable_manager();
  PROTOBUF_NODISCARD std::string* release_manager();
  void set_allocated_manager(std::string* manager);
  private:
  const std::string& _internal_manager() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_manager(const std::string& value);
  std::string* _internal_mutable_manager();
  public:

  // string deviceId = 2;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string OperationSystem = 4;
  void clear_operationsystem();
  const std::string& operationsystem() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operationsystem(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operationsystem();
  PROTOBUF_NODISCARD std::string* release_operationsystem();
  void set_allocated_operationsystem(std::string* operationsystem);
  private:
  const std::string& _internal_operationsystem() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operationsystem(const std::string& value);
  std::string* _internal_mutable_operationsystem();
  public:

  // string SupportedArchitectures = 5;
  void clear_supportedarchitectures();
  const std::string& supportedarchitectures() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_supportedarchitectures(ArgT0&& arg0, ArgT... args);
  std::string* mutable_supportedarchitectures();
  PROTOBUF_NODISCARD std::string* release_supportedarchitectures();
  void set_allocated_supportedarchitectures(std::string* supportedarchitectures);
  private:
  const std::string& _internal_supportedarchitectures() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_supportedarchitectures(const std::string& value);
  std::string* _internal_mutable_supportedarchitectures();
  public:

  // string Status = 6;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // @@protoc_insertion_point(class_scope:action.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manager_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operationsystem_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr supportedarchitectures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class DeviceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:action.DeviceRequest) */ {
 public:
  inline DeviceRequest() : DeviceRequest(nullptr) {}
  explicit constexpr DeviceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceRequest(const DeviceRequest& from);
  DeviceRequest(DeviceRequest&& from) noexcept
    : DeviceRequest() {
    *this = ::std::move(from);
  }

  inline DeviceRequest& operator=(const DeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceRequest& operator=(DeviceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceRequest* internal_default_instance() {
    return reinterpret_cast<const DeviceRequest*>(
               &_DeviceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeviceRequest& a, DeviceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeviceRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeviceRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.DeviceRequest";
  }
  protected:
  explicit DeviceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:action.DeviceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class DeviceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.DeviceResponse) */ {
 public:
  inline DeviceResponse() : DeviceResponse(nullptr) {}
  ~DeviceResponse() override;
  explicit constexpr DeviceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceResponse(const DeviceResponse& from);
  DeviceResponse(DeviceResponse&& from) noexcept
    : DeviceResponse() {
    *this = ::std::move(from);
  }

  inline DeviceResponse& operator=(const DeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceResponse& operator=(DeviceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceResponse* internal_default_instance() {
    return reinterpret_cast<const DeviceResponse*>(
               &_DeviceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeviceResponse& a, DeviceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.DeviceResponse";
  }
  protected:
  explicit DeviceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDevicesFieldNumber = 1,
  };
  // repeated .action.Device devices = 1;
  int devices_size() const;
  private:
  int _internal_devices_size() const;
  public:
  void clear_devices();
  ::action::Device* mutable_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Device >*
      mutable_devices();
  private:
  const ::action::Device& _internal_devices(int index) const;
  ::action::Device* _internal_add_devices();
  public:
  const ::action::Device& devices(int index) const;
  ::action::Device* add_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Device >&
      devices() const;

  // @@protoc_insertion_point(class_scope:action.DeviceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Device > devices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class InteractionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.InteractionRequest) */ {
 public:
  inline InteractionRequest() : InteractionRequest(nullptr) {}
  ~InteractionRequest() override;
  explicit constexpr InteractionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InteractionRequest(const InteractionRequest& from);
  InteractionRequest(InteractionRequest&& from) noexcept
    : InteractionRequest() {
    *this = ::std::move(from);
  }

  inline InteractionRequest& operator=(const InteractionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InteractionRequest& operator=(InteractionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InteractionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InteractionRequest* internal_default_instance() {
    return reinterpret_cast<const InteractionRequest*>(
               &_InteractionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InteractionRequest& a, InteractionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InteractionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InteractionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InteractionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InteractionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InteractionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InteractionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InteractionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.InteractionRequest";
  }
  protected:
  explicit InteractionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIDFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string DeviceID = 1;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // .action.DeviceInteractionType type = 2;
  void clear_type();
  ::action::DeviceInteractionType type() const;
  void set_type(::action::DeviceInteractionType value);
  private:
  ::action::DeviceInteractionType _internal_type() const;
  void _internal_set_type(::action::DeviceInteractionType value);
  public:

  // @@protoc_insertion_point(class_scope:action.InteractionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class InteractionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:action.InteractionResponse) */ {
 public:
  inline InteractionResponse() : InteractionResponse(nullptr) {}
  explicit constexpr InteractionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InteractionResponse(const InteractionResponse& from);
  InteractionResponse(InteractionResponse&& from) noexcept
    : InteractionResponse() {
    *this = ::std::move(from);
  }

  inline InteractionResponse& operator=(const InteractionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InteractionResponse& operator=(InteractionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InteractionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InteractionResponse* internal_default_instance() {
    return reinterpret_cast<const InteractionResponse*>(
               &_InteractionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(InteractionResponse& a, InteractionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InteractionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InteractionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InteractionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InteractionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InteractionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InteractionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.InteractionResponse";
  }
  protected:
  explicit InteractionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:action.InteractionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class SetAttr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.SetAttr) */ {
 public:
  inline SetAttr() : SetAttr(nullptr) {}
  ~SetAttr() override;
  explicit constexpr SetAttr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetAttr(const SetAttr& from);
  SetAttr(SetAttr&& from) noexcept
    : SetAttr() {
    *this = ::std::move(from);
  }

  inline SetAttr& operator=(const SetAttr& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAttr& operator=(SetAttr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAttr& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAttr* internal_default_instance() {
    return reinterpret_cast<const SetAttr*>(
               &_SetAttr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SetAttr& a, SetAttr& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAttr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAttr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAttr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAttr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetAttr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetAttr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetAttr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.SetAttr";
  }
  protected:
  explicit SetAttr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAttrFieldNumber = 2,
    kValFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string attr = 2;
  void clear_attr();
  const std::string& attr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attr();
  PROTOBUF_NODISCARD std::string* release_attr();
  void set_allocated_attr(std::string* attr);
  private:
  const std::string& _internal_attr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attr(const std::string& value);
  std::string* _internal_mutable_attr();
  public:

  // string val = 3;
  void clear_val();
  const std::string& val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_val();
  PROTOBUF_NODISCARD std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:action.SetAttr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class GetAttr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.GetAttr) */ {
 public:
  inline GetAttr() : GetAttr(nullptr) {}
  ~GetAttr() override;
  explicit constexpr GetAttr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAttr(const GetAttr& from);
  GetAttr(GetAttr&& from) noexcept
    : GetAttr() {
    *this = ::std::move(from);
  }

  inline GetAttr& operator=(const GetAttr& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAttr& operator=(GetAttr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAttr& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAttr* internal_default_instance() {
    return reinterpret_cast<const GetAttr*>(
               &_GetAttr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetAttr& a, GetAttr& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAttr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAttr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAttr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAttr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAttr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAttr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAttr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.GetAttr";
  }
  protected:
  explicit GetAttr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAttrFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string attr = 2;
  void clear_attr();
  const std::string& attr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attr();
  PROTOBUF_NODISCARD std::string* release_attr();
  void set_allocated_attr(std::string* attr);
  private:
  const std::string& _internal_attr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attr(const std::string& value);
  std::string* _internal_mutable_attr();
  public:

  // @@protoc_insertion_point(class_scope:action.GetAttr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attr_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class MoveOffset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.MoveOffset) */ {
 public:
  inline MoveOffset() : MoveOffset(nullptr) {}
  ~MoveOffset() override;
  explicit constexpr MoveOffset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveOffset(const MoveOffset& from);
  MoveOffset(MoveOffset&& from) noexcept
    : MoveOffset() {
    *this = ::std::move(from);
  }

  inline MoveOffset& operator=(const MoveOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveOffset& operator=(MoveOffset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveOffset& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveOffset* internal_default_instance() {
    return reinterpret_cast<const MoveOffset*>(
               &_MoveOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MoveOffset& a, MoveOffset& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveOffset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveOffset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveOffset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveOffset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveOffset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveOffset& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveOffset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.MoveOffset";
  }
  protected:
  explicit MoveOffset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // int64 from = 1;
  void clear_from();
  int64_t from() const;
  void set_from(int64_t value);
  private:
  int64_t _internal_from() const;
  void _internal_set_from(int64_t value);
  public:

  // int64 to = 2;
  void clear_to();
  int64_t to() const;
  void set_to(int64_t value);
  private:
  int64_t _internal_to() const;
  void _internal_set_to(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:action.MoveOffset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t from_;
  int64_t to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class MoveElement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.MoveElement) */ {
 public:
  inline MoveElement() : MoveElement(nullptr) {}
  ~MoveElement() override;
  explicit constexpr MoveElement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveElement(const MoveElement& from);
  MoveElement(MoveElement&& from) noexcept
    : MoveElement() {
    *this = ::std::move(from);
  }

  inline MoveElement& operator=(const MoveElement& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveElement& operator=(MoveElement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveElement& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveElement* internal_default_instance() {
    return reinterpret_cast<const MoveElement*>(
               &_MoveElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MoveElement& a, MoveElement& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveElement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveElement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveElement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveElement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveElement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveElement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveElement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.MoveElement";
  }
  protected:
  explicit MoveElement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // string from = 1;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // string to = 2;
  void clear_to();
  const std::string& to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to();
  PROTOBUF_NODISCARD std::string* release_to();
  void set_allocated_to(std::string* to);
  private:
  const std::string& _internal_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
  std::string* _internal_mutable_to();
  public:

  // @@protoc_insertion_point(class_scope:action.MoveElement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class Touch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Touch) */ {
 public:
  inline Touch() : Touch(nullptr) {}
  ~Touch() override;
  explicit constexpr Touch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Touch(const Touch& from);
  Touch(Touch&& from) noexcept
    : Touch() {
    *this = ::std::move(from);
  }

  inline Touch& operator=(const Touch& from) {
    CopyFrom(from);
    return *this;
  }
  inline Touch& operator=(Touch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Touch& default_instance() {
    return *internal_default_instance();
  }
  static inline const Touch* internal_default_instance() {
    return reinterpret_cast<const Touch*>(
               &_Touch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Touch& a, Touch& b) {
    a.Swap(&b);
  }
  inline void Swap(Touch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Touch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Touch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Touch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Touch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Touch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Touch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Touch";
  }
  protected:
  explicit Touch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXoffsetFieldNumber = 2,
    kYoffsetFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int64 xoffset = 2;
  void clear_xoffset();
  int64_t xoffset() const;
  void set_xoffset(int64_t value);
  private:
  int64_t _internal_xoffset() const;
  void _internal_set_xoffset(int64_t value);
  public:

  // int64 yoffset = 3;
  void clear_yoffset();
  int64_t yoffset() const;
  void set_yoffset(int64_t value);
  private:
  int64_t _internal_yoffset() const;
  void _internal_set_yoffset(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:action.Touch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int64_t xoffset_;
  int64_t yoffset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit constexpr Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kId = 3,
    kData = 4,
    kSetAttr = 5,
    kGetAttr = 6,
    kMoveOffset = 7,
    kTouch = 8,
    kMoveElement = 9,
    kTest = 10,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionIDFieldNumber = 1,
    kActionTypeFieldNumber = 2,
    kIdFieldNumber = 3,
    kDataFieldNumber = 4,
    kSetAttrFieldNumber = 5,
    kGetAttrFieldNumber = 6,
    kMoveOffsetFieldNumber = 7,
    kTouchFieldNumber = 8,
    kMoveElementFieldNumber = 9,
    kTestFieldNumber = 10,
  };
  // string actionID = 1;
  void clear_actionid();
  const std::string& actionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actionid();
  PROTOBUF_NODISCARD std::string* release_actionid();
  void set_allocated_actionid(std::string* actionid);
  private:
  const std::string& _internal_actionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actionid(const std::string& value);
  std::string* _internal_mutable_actionid();
  public:

  // .action.ActionType actionType = 2;
  void clear_actiontype();
  ::action::ActionType actiontype() const;
  void set_actiontype(::action::ActionType value);
  private:
  ::action::ActionType _internal_actiontype() const;
  void _internal_set_actiontype(::action::ActionType value);
  public:

  // string id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .action.SetAttr setAttr = 5;
  bool has_setattr() const;
  private:
  bool _internal_has_setattr() const;
  public:
  void clear_setattr();
  const ::action::SetAttr& setattr() const;
  PROTOBUF_NODISCARD ::action::SetAttr* release_setattr();
  ::action::SetAttr* mutable_setattr();
  void set_allocated_setattr(::action::SetAttr* setattr);
  private:
  const ::action::SetAttr& _internal_setattr() const;
  ::action::SetAttr* _internal_mutable_setattr();
  public:
  void unsafe_arena_set_allocated_setattr(
      ::action::SetAttr* setattr);
  ::action::SetAttr* unsafe_arena_release_setattr();

  // .action.GetAttr getAttr = 6;
  bool has_getattr() const;
  private:
  bool _internal_has_getattr() const;
  public:
  void clear_getattr();
  const ::action::GetAttr& getattr() const;
  PROTOBUF_NODISCARD ::action::GetAttr* release_getattr();
  ::action::GetAttr* mutable_getattr();
  void set_allocated_getattr(::action::GetAttr* getattr);
  private:
  const ::action::GetAttr& _internal_getattr() const;
  ::action::GetAttr* _internal_mutable_getattr();
  public:
  void unsafe_arena_set_allocated_getattr(
      ::action::GetAttr* getattr);
  ::action::GetAttr* unsafe_arena_release_getattr();

  // .action.MoveOffset moveOffset = 7;
  bool has_moveoffset() const;
  private:
  bool _internal_has_moveoffset() const;
  public:
  void clear_moveoffset();
  const ::action::MoveOffset& moveoffset() const;
  PROTOBUF_NODISCARD ::action::MoveOffset* release_moveoffset();
  ::action::MoveOffset* mutable_moveoffset();
  void set_allocated_moveoffset(::action::MoveOffset* moveoffset);
  private:
  const ::action::MoveOffset& _internal_moveoffset() const;
  ::action::MoveOffset* _internal_mutable_moveoffset();
  public:
  void unsafe_arena_set_allocated_moveoffset(
      ::action::MoveOffset* moveoffset);
  ::action::MoveOffset* unsafe_arena_release_moveoffset();

  // .action.Touch touch = 8;
  bool has_touch() const;
  private:
  bool _internal_has_touch() const;
  public:
  void clear_touch();
  const ::action::Touch& touch() const;
  PROTOBUF_NODISCARD ::action::Touch* release_touch();
  ::action::Touch* mutable_touch();
  void set_allocated_touch(::action::Touch* touch);
  private:
  const ::action::Touch& _internal_touch() const;
  ::action::Touch* _internal_mutable_touch();
  public:
  void unsafe_arena_set_allocated_touch(
      ::action::Touch* touch);
  ::action::Touch* unsafe_arena_release_touch();

  // .action.MoveElement moveElement = 9;
  bool has_moveelement() const;
  private:
  bool _internal_has_moveelement() const;
  public:
  void clear_moveelement();
  const ::action::MoveElement& moveelement() const;
  PROTOBUF_NODISCARD ::action::MoveElement* release_moveelement();
  ::action::MoveElement* mutable_moveelement();
  void set_allocated_moveelement(::action::MoveElement* moveelement);
  private:
  const ::action::MoveElement& _internal_moveelement() const;
  ::action::MoveElement* _internal_mutable_moveelement();
  public:
  void unsafe_arena_set_allocated_moveelement(
      ::action::MoveElement* moveelement);
  ::action::MoveElement* unsafe_arena_release_moveelement();

  // .action.Test test = 10;
  bool has_test() const;
  private:
  bool _internal_has_test() const;
  public:
  void clear_test();
  const ::action::Test& test() const;
  PROTOBUF_NODISCARD ::action::Test* release_test();
  ::action::Test* mutable_test();
  void set_allocated_test(::action::Test* test);
  private:
  const ::action::Test& _internal_test() const;
  ::action::Test* _internal_mutable_test();
  public:
  void unsafe_arena_set_allocated_test(
      ::action::Test* test);
  ::action::Test* unsafe_arena_release_test();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:action.Request)
 private:
  class _Internal;
  void set_has_id();
  void set_has_data();
  void set_has_setattr();
  void set_has_getattr();
  void set_has_moveoffset();
  void set_has_touch();
  void set_has_moveelement();
  void set_has_test();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actionid_;
  int actiontype_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::action::SetAttr* setattr_;
    ::action::GetAttr* getattr_;
    ::action::MoveOffset* moveoffset_;
    ::action::Touch* touch_;
    ::action::MoveElement* moveelement_;
    ::action::Test* test_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class Connect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Connect) */ {
 public:
  inline Connect() : Connect(nullptr) {}
  ~Connect() override;
  explicit constexpr Connect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connect(const Connect& from);
  Connect(Connect&& from) noexcept
    : Connect() {
    *this = ::std::move(from);
  }

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connect& operator=(Connect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connect* internal_default_instance() {
    return reinterpret_cast<const Connect*>(
               &_Connect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Connect& a, Connect& b) {
    a.Swap(&b);
  }
  inline void Swap(Connect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Connect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Connect";
  }
  protected:
  explicit Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomerIdFieldNumber = 1,
    kAppIDFieldNumber = 2,
    kDeviceIDFieldNumber = 4,
    kSessionIDFieldNumber = 5,
    kVersionFieldNumber = 6,
    kAppTypeFieldNumber = 3,
  };
  // string customerId = 1;
  void clear_customerid();
  const std::string& customerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customerid();
  PROTOBUF_NODISCARD std::string* release_customerid();
  void set_allocated_customerid(std::string* customerid);
  private:
  const std::string& _internal_customerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customerid(const std::string& value);
  std::string* _internal_mutable_customerid();
  public:

  // string appID = 2;
  void clear_appid();
  const std::string& appid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appid();
  PROTOBUF_NODISCARD std::string* release_appid();
  void set_allocated_appid(std::string* appid);
  private:
  const std::string& _internal_appid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appid(const std::string& value);
  std::string* _internal_mutable_appid();
  public:

  // string deviceID = 4;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string sessionID = 5;
  void clear_sessionid();
  const std::string& sessionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sessionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sessionid();
  PROTOBUF_NODISCARD std::string* release_sessionid();
  void set_allocated_sessionid(std::string* sessionid);
  private:
  const std::string& _internal_sessionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sessionid(const std::string& value);
  std::string* _internal_mutable_sessionid();
  public:

  // string version = 6;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .action.AppType appType = 3;
  void clear_apptype();
  ::action::AppType apptype() const;
  void set_apptype(::action::AppType value);
  private:
  ::action::AppType _internal_apptype() const;
  void _internal_set_apptype(::action::AppType value);
  public:

  // @@protoc_insertion_point(class_scope:action.Connect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customerid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  int apptype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class Screenshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Screenshot) */ {
 public:
  inline Screenshot() : Screenshot(nullptr) {}
  ~Screenshot() override;
  explicit constexpr Screenshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Screenshot(const Screenshot& from);
  Screenshot(Screenshot&& from) noexcept
    : Screenshot() {
    *this = ::std::move(from);
  }

  inline Screenshot& operator=(const Screenshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Screenshot& operator=(Screenshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Screenshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const Screenshot* internal_default_instance() {
    return reinterpret_cast<const Screenshot*>(
               &_Screenshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Screenshot& a, Screenshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Screenshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Screenshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Screenshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Screenshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Screenshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Screenshot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Screenshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Screenshot";
  }
  protected:
  explicit Screenshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSceengraphFieldNumber = 1,
    kScreenshotFieldNumber = 2,
    kContentTypeFieldNumber = 3,
  };
  // bytes sceengraph = 1;
  void clear_sceengraph();
  const std::string& sceengraph() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sceengraph(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sceengraph();
  PROTOBUF_NODISCARD std::string* release_sceengraph();
  void set_allocated_sceengraph(std::string* sceengraph);
  private:
  const std::string& _internal_sceengraph() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sceengraph(const std::string& value);
  std::string* _internal_mutable_sceengraph();
  public:

  // bytes screenshot = 2;
  void clear_screenshot();
  const std::string& screenshot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_screenshot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_screenshot();
  PROTOBUF_NODISCARD std::string* release_screenshot();
  void set_allocated_screenshot(std::string* screenshot);
  private:
  const std::string& _internal_screenshot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_screenshot(const std::string& value);
  std::string* _internal_mutable_screenshot();
  public:

  // .action.ContentType contentType = 3;
  void clear_contenttype();
  ::action::ContentType contenttype() const;
  void set_contenttype(::action::ContentType value);
  private:
  ::action::ContentType _internal_contenttype() const;
  void _internal_set_contenttype(::action::ContentType value);
  public:

  // @@protoc_insertion_point(class_scope:action.Screenshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sceengraph_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr screenshot_;
  int contenttype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class Test_ParameterEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Test_ParameterEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Test_ParameterEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Test_ParameterEntry_DoNotUse();
  explicit constexpr Test_ParameterEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Test_ParameterEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Test_ParameterEntry_DoNotUse& other);
  static const Test_ParameterEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Test_ParameterEntry_DoNotUse*>(&_Test_ParameterEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "action.Test.ParameterEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "action.Test.ParameterEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Test final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Test) */ {
 public:
  inline Test() : Test(nullptr) {}
  ~Test() override;
  explicit constexpr Test(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Test(const Test& from);
  Test(Test&& from) noexcept
    : Test() {
    *this = ::std::move(from);
  }

  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }
  inline Test& operator=(Test&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Test& default_instance() {
    return *internal_default_instance();
  }
  static inline const Test* internal_default_instance() {
    return reinterpret_cast<const Test*>(
               &_Test_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Test& a, Test& b) {
    a.Swap(&b);
  }
  inline void Swap(Test* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Test* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Test* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Test>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Test& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Test& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Test* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Test";
  }
  protected:
  explicit Test(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kParameterFieldNumber = 4,
    kCategoriesFieldNumber = 5,
    kAssemblyFieldNumber = 1,
    kClassFieldNumber = 2,
    kMethodFieldNumber = 3,
  };
  // map<string, string> parameter = 4;
  int parameter_size() const;
  private:
  int _internal_parameter_size() const;
  public:
  void clear_parameter();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameter() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameter();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameter() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameter();

  // repeated string categories = 5;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, size_t size);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();
  private:
  const std::string& _internal_categories(int index) const;
  std::string* _internal_add_categories();
  public:

  // string assembly = 1;
  void clear_assembly();
  const std::string& assembly() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assembly(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assembly();
  PROTOBUF_NODISCARD std::string* release_assembly();
  void set_allocated_assembly(std::string* assembly);
  private:
  const std::string& _internal_assembly() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assembly(const std::string& value);
  std::string* _internal_mutable_assembly();
  public:

  // string class = 2;
  void clear_class_();
  const std::string& class_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_class_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_class_();
  PROTOBUF_NODISCARD std::string* release_class_();
  void set_allocated_class_(std::string* class_);
  private:
  const std::string& _internal_class_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_(const std::string& value);
  std::string* _internal_mutable_class_();
  public:

  // string method = 3;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // @@protoc_insertion_point(class_scope:action.Test)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Test_ParameterEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> parameter_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assembly_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class Tests final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Tests) */ {
 public:
  inline Tests() : Tests(nullptr) {}
  ~Tests() override;
  explicit constexpr Tests(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tests(const Tests& from);
  Tests(Tests&& from) noexcept
    : Tests() {
    *this = ::std::move(from);
  }

  inline Tests& operator=(const Tests& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tests& operator=(Tests&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tests& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tests* internal_default_instance() {
    return reinterpret_cast<const Tests*>(
               &_Tests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Tests& a, Tests& b) {
    a.Swap(&b);
  }
  inline void Swap(Tests* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tests>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tests& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Tests& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tests* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Tests";
  }
  protected:
  explicit Tests(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTestsFieldNumber = 1,
  };
  // repeated .action.Test tests = 1;
  int tests_size() const;
  private:
  int _internal_tests_size() const;
  public:
  void clear_tests();
  ::action::Test* mutable_tests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Test >*
      mutable_tests();
  private:
  const ::action::Test& _internal_tests(int index) const;
  ::action::Test* _internal_add_tests();
  public:
  const ::action::Test& tests(int index) const;
  ::action::Test* add_tests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Test >&
      tests() const;

  // @@protoc_insertion_point(class_scope:action.Tests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Test > tests_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class LogData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.LogData) */ {
 public:
  inline LogData() : LogData(nullptr) {}
  ~LogData() override;
  explicit constexpr LogData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogData(const LogData& from);
  LogData(LogData&& from) noexcept
    : LogData() {
    *this = ::std::move(from);
  }

  inline LogData& operator=(const LogData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogData& operator=(LogData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogData* internal_default_instance() {
    return reinterpret_cast<const LogData*>(
               &_LogData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LogData& a, LogData& b) {
    a.Swap(&b);
  }
  inline void Swap(LogData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.LogData";
  }
  protected:
  explicit LogData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kTypeFieldNumber = 1,
    kLevelFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .action.LogType type = 1;
  void clear_type();
  ::action::LogType type() const;
  void set_type(::action::LogType value);
  private:
  ::action::LogType _internal_type() const;
  void _internal_set_type(::action::LogType value);
  public:

  // .action.LogLevel level = 2;
  void clear_level();
  ::action::LogLevel level() const;
  void set_level(::action::LogLevel value);
  private:
  ::action::LogLevel _internal_level() const;
  void _internal_set_level(::action::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:action.LogData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int type_;
  int level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class TestDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.TestDetails) */ {
 public:
  inline TestDetails() : TestDetails(nullptr) {}
  ~TestDetails() override;
  explicit constexpr TestDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TestDetails(const TestDetails& from);
  TestDetails(TestDetails&& from) noexcept
    : TestDetails() {
    *this = ::std::move(from);
  }

  inline TestDetails& operator=(const TestDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestDetails& operator=(TestDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TestDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const TestDetails* internal_default_instance() {
    return reinterpret_cast<const TestDetails*>(
               &_TestDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TestDetails& a, TestDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(TestDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TestDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TestDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TestDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TestDetails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.TestDetails";
  }
  protected:
  explicit TestDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 2,
    kTimeoutFieldNumber = 1,
  };
  // repeated string categories = 2;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  const std::string& categories(int index) const;
  std::string* mutable_categories(int index);
  void set_categories(int index, const std::string& value);
  void set_categories(int index, std::string&& value);
  void set_categories(int index, const char* value);
  void set_categories(int index, const char* value, size_t size);
  std::string* add_categories();
  void add_categories(const std::string& value);
  void add_categories(std::string&& value);
  void add_categories(const char* value);
  void add_categories(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();
  private:
  const std::string& _internal_categories(int index) const;
  std::string* _internal_add_categories();
  public:

  // int32 timeout = 1;
  void clear_timeout();
  int32_t timeout() const;
  void set_timeout(int32_t value);
  private:
  int32_t _internal_timeout() const;
  void _internal_set_timeout(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:action.TestDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
  int32_t timeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class PerformanceData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.PerformanceData) */ {
 public:
  inline PerformanceData() : PerformanceData(nullptr) {}
  ~PerformanceData() override;
  explicit constexpr PerformanceData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PerformanceData(const PerformanceData& from);
  PerformanceData(PerformanceData&& from) noexcept
    : PerformanceData() {
    *this = ::std::move(from);
  }

  inline PerformanceData& operator=(const PerformanceData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PerformanceData& operator=(PerformanceData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PerformanceData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PerformanceData* internal_default_instance() {
    return reinterpret_cast<const PerformanceData*>(
               &_PerformanceData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PerformanceData& a, PerformanceData& b) {
    a.Swap(&b);
  }
  inline void Swap(PerformanceData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PerformanceData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PerformanceData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PerformanceData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PerformanceData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PerformanceData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PerformanceData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.PerformanceData";
  }
  protected:
  explicit PerformanceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheckpointFieldNumber = 1,
    kCpuFieldNumber = 2,
    kMemoryFieldNumber = 3,
    kFpsFieldNumber = 4,
  };
  // string checkpoint = 1;
  void clear_checkpoint();
  const std::string& checkpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checkpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checkpoint();
  PROTOBUF_NODISCARD std::string* release_checkpoint();
  void set_allocated_checkpoint(std::string* checkpoint);
  private:
  const std::string& _internal_checkpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checkpoint(const std::string& value);
  std::string* _internal_mutable_checkpoint();
  public:

  // float cpu = 2;
  void clear_cpu();
  float cpu() const;
  void set_cpu(float value);
  private:
  float _internal_cpu() const;
  void _internal_set_cpu(float value);
  public:

  // float memory = 3;
  void clear_memory();
  float memory() const;
  void set_memory(float value);
  private:
  float _internal_memory() const;
  void _internal_set_memory(float value);
  public:

  // float fps = 4;
  void clear_fps();
  float fps() const;
  void set_fps(float value);
  private:
  float _internal_fps() const;
  void _internal_set_fps(float value);
  public:

  // @@protoc_insertion_point(class_scope:action.PerformanceData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checkpoint_;
  float cpu_;
  float memory_;
  float fps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_action_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:action.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kVisible = 4,
    kData = 5,
    kValue = 6,
    kScreenshot = 7,
    kConnect = 8,
    kTests = 9,
    kLog = 10,
    kTestDetails = 11,
    kPerformance = 12,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "action.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionIDFieldNumber = 1,
    kActionTypeFieldNumber = 2,
    kSuccessFieldNumber = 3,
    kVisibleFieldNumber = 4,
    kDataFieldNumber = 5,
    kValueFieldNumber = 6,
    kScreenshotFieldNumber = 7,
    kConnectFieldNumber = 8,
    kTestsFieldNumber = 9,
    kLogFieldNumber = 10,
    kTestDetailsFieldNumber = 11,
    kPerformanceFieldNumber = 12,
  };
  // string actionID = 1;
  void clear_actionid();
  const std::string& actionid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_actionid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_actionid();
  PROTOBUF_NODISCARD std::string* release_actionid();
  void set_allocated_actionid(std::string* actionid);
  private:
  const std::string& _internal_actionid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_actionid(const std::string& value);
  std::string* _internal_mutable_actionid();
  public:

  // .action.ActionType actionType = 2;
  void clear_actiontype();
  ::action::ActionType actiontype() const;
  void set_actiontype(::action::ActionType value);
  private:
  ::action::ActionType _internal_actiontype() const;
  void _internal_set_actiontype(::action::ActionType value);
  public:

  // bool success = 3;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool visible = 4;
  bool has_visible() const;
  private:
  bool _internal_has_visible() const;
  public:
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // bytes data = 5;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string value = 6;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .action.Screenshot screenshot = 7;
  bool has_screenshot() const;
  private:
  bool _internal_has_screenshot() const;
  public:
  void clear_screenshot();
  const ::action::Screenshot& screenshot() const;
  PROTOBUF_NODISCARD ::action::Screenshot* release_screenshot();
  ::action::Screenshot* mutable_screenshot();
  void set_allocated_screenshot(::action::Screenshot* screenshot);
  private:
  const ::action::Screenshot& _internal_screenshot() const;
  ::action::Screenshot* _internal_mutable_screenshot();
  public:
  void unsafe_arena_set_allocated_screenshot(
      ::action::Screenshot* screenshot);
  ::action::Screenshot* unsafe_arena_release_screenshot();

  // .action.Connect connect = 8;
  bool has_connect() const;
  private:
  bool _internal_has_connect() const;
  public:
  void clear_connect();
  const ::action::Connect& connect() const;
  PROTOBUF_NODISCARD ::action::Connect* release_connect();
  ::action::Connect* mutable_connect();
  void set_allocated_connect(::action::Connect* connect);
  private:
  const ::action::Connect& _internal_connect() const;
  ::action::Connect* _internal_mutable_connect();
  public:
  void unsafe_arena_set_allocated_connect(
      ::action::Connect* connect);
  ::action::Connect* unsafe_arena_release_connect();

  // .action.Tests tests = 9;
  bool has_tests() const;
  private:
  bool _internal_has_tests() const;
  public:
  void clear_tests();
  const ::action::Tests& tests() const;
  PROTOBUF_NODISCARD ::action::Tests* release_tests();
  ::action::Tests* mutable_tests();
  void set_allocated_tests(::action::Tests* tests);
  private:
  const ::action::Tests& _internal_tests() const;
  ::action::Tests* _internal_mutable_tests();
  public:
  void unsafe_arena_set_allocated_tests(
      ::action::Tests* tests);
  ::action::Tests* unsafe_arena_release_tests();

  // .action.LogData log = 10;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const ::action::LogData& log() const;
  PROTOBUF_NODISCARD ::action::LogData* release_log();
  ::action::LogData* mutable_log();
  void set_allocated_log(::action::LogData* log);
  private:
  const ::action::LogData& _internal_log() const;
  ::action::LogData* _internal_mutable_log();
  public:
  void unsafe_arena_set_allocated_log(
      ::action::LogData* log);
  ::action::LogData* unsafe_arena_release_log();

  // .action.TestDetails testDetails = 11;
  bool has_testdetails() const;
  private:
  bool _internal_has_testdetails() const;
  public:
  void clear_testdetails();
  const ::action::TestDetails& testdetails() const;
  PROTOBUF_NODISCARD ::action::TestDetails* release_testdetails();
  ::action::TestDetails* mutable_testdetails();
  void set_allocated_testdetails(::action::TestDetails* testdetails);
  private:
  const ::action::TestDetails& _internal_testdetails() const;
  ::action::TestDetails* _internal_mutable_testdetails();
  public:
  void unsafe_arena_set_allocated_testdetails(
      ::action::TestDetails* testdetails);
  ::action::TestDetails* unsafe_arena_release_testdetails();

  // .action.PerformanceData performance = 12;
  bool has_performance() const;
  private:
  bool _internal_has_performance() const;
  public:
  void clear_performance();
  const ::action::PerformanceData& performance() const;
  PROTOBUF_NODISCARD ::action::PerformanceData* release_performance();
  ::action::PerformanceData* mutable_performance();
  void set_allocated_performance(::action::PerformanceData* performance);
  private:
  const ::action::PerformanceData& _internal_performance() const;
  ::action::PerformanceData* _internal_mutable_performance();
  public:
  void unsafe_arena_set_allocated_performance(
      ::action::PerformanceData* performance);
  ::action::PerformanceData* unsafe_arena_release_performance();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:action.Response)
 private:
  class _Internal;
  void set_has_visible();
  void set_has_data();
  void set_has_value();
  void set_has_screenshot();
  void set_has_connect();
  void set_has_tests();
  void set_has_log();
  void set_has_testdetails();
  void set_has_performance();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr actionid_;
  int actiontype_;
  bool success_;
  union PayloadUnion {
    constexpr PayloadUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool visible_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::action::Screenshot* screenshot_;
    ::action::Connect* connect_;
    ::action::Tests* tests_;
    ::action::LogData* log_;
    ::action::TestDetails* testdetails_;
    ::action::PerformanceData* performance_;
  } payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_action_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Device

// string manager = 1;
inline void Device::clear_manager() {
  manager_.ClearToEmpty();
}
inline const std::string& Device::manager() const {
  // @@protoc_insertion_point(field_get:action.Device.manager)
  return _internal_manager();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_manager(ArgT0&& arg0, ArgT... args) {
 
 manager_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Device.manager)
}
inline std::string* Device::mutable_manager() {
  std::string* _s = _internal_mutable_manager();
  // @@protoc_insertion_point(field_mutable:action.Device.manager)
  return _s;
}
inline const std::string& Device::_internal_manager() const {
  return manager_.Get();
}
inline void Device::_internal_set_manager(const std::string& value) {
  
  manager_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_manager() {
  
  return manager_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_manager() {
  // @@protoc_insertion_point(field_release:action.Device.manager)
  return manager_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_manager(std::string* manager) {
  if (manager != nullptr) {
    
  } else {
    
  }
  manager_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manager,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (manager_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    manager_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Device.manager)
}

// string deviceId = 2;
inline void Device::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& Device::deviceid() const {
  // @@protoc_insertion_point(field_get:action.Device.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Device.deviceId)
}
inline std::string* Device::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:action.Device.deviceId)
  return _s;
}
inline const std::string& Device::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void Device::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_deviceid() {
  // @@protoc_insertion_point(field_release:action.Device.deviceId)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deviceid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deviceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Device.deviceId)
}

// string name = 3;
inline void Device::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Device::name() const {
  // @@protoc_insertion_point(field_get:action.Device.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Device.name)
}
inline std::string* Device::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:action.Device.name)
  return _s;
}
inline const std::string& Device::_internal_name() const {
  return name_.Get();
}
inline void Device::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_name() {
  // @@protoc_insertion_point(field_release:action.Device.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Device.name)
}

// string OperationSystem = 4;
inline void Device::clear_operationsystem() {
  operationsystem_.ClearToEmpty();
}
inline const std::string& Device::operationsystem() const {
  // @@protoc_insertion_point(field_get:action.Device.OperationSystem)
  return _internal_operationsystem();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_operationsystem(ArgT0&& arg0, ArgT... args) {
 
 operationsystem_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Device.OperationSystem)
}
inline std::string* Device::mutable_operationsystem() {
  std::string* _s = _internal_mutable_operationsystem();
  // @@protoc_insertion_point(field_mutable:action.Device.OperationSystem)
  return _s;
}
inline const std::string& Device::_internal_operationsystem() const {
  return operationsystem_.Get();
}
inline void Device::_internal_set_operationsystem(const std::string& value) {
  
  operationsystem_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_operationsystem() {
  
  return operationsystem_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_operationsystem() {
  // @@protoc_insertion_point(field_release:action.Device.OperationSystem)
  return operationsystem_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_operationsystem(std::string* operationsystem) {
  if (operationsystem != nullptr) {
    
  } else {
    
  }
  operationsystem_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operationsystem,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operationsystem_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operationsystem_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Device.OperationSystem)
}

// string SupportedArchitectures = 5;
inline void Device::clear_supportedarchitectures() {
  supportedarchitectures_.ClearToEmpty();
}
inline const std::string& Device::supportedarchitectures() const {
  // @@protoc_insertion_point(field_get:action.Device.SupportedArchitectures)
  return _internal_supportedarchitectures();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_supportedarchitectures(ArgT0&& arg0, ArgT... args) {
 
 supportedarchitectures_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Device.SupportedArchitectures)
}
inline std::string* Device::mutable_supportedarchitectures() {
  std::string* _s = _internal_mutable_supportedarchitectures();
  // @@protoc_insertion_point(field_mutable:action.Device.SupportedArchitectures)
  return _s;
}
inline const std::string& Device::_internal_supportedarchitectures() const {
  return supportedarchitectures_.Get();
}
inline void Device::_internal_set_supportedarchitectures(const std::string& value) {
  
  supportedarchitectures_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_supportedarchitectures() {
  
  return supportedarchitectures_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_supportedarchitectures() {
  // @@protoc_insertion_point(field_release:action.Device.SupportedArchitectures)
  return supportedarchitectures_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_supportedarchitectures(std::string* supportedarchitectures) {
  if (supportedarchitectures != nullptr) {
    
  } else {
    
  }
  supportedarchitectures_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), supportedarchitectures,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (supportedarchitectures_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    supportedarchitectures_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Device.SupportedArchitectures)
}

// string Status = 6;
inline void Device::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& Device::status() const {
  // @@protoc_insertion_point(field_get:action.Device.Status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Device::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Device.Status)
}
inline std::string* Device::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:action.Device.Status)
  return _s;
}
inline const std::string& Device::_internal_status() const {
  return status_.Get();
}
inline void Device::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Device::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Device::release_status() {
  // @@protoc_insertion_point(field_release:action.Device.Status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Device::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Device.Status)
}

// -------------------------------------------------------------------

// DeviceRequest

// -------------------------------------------------------------------

// DeviceResponse

// repeated .action.Device devices = 1;
inline int DeviceResponse::_internal_devices_size() const {
  return devices_.size();
}
inline int DeviceResponse::devices_size() const {
  return _internal_devices_size();
}
inline void DeviceResponse::clear_devices() {
  devices_.Clear();
}
inline ::action::Device* DeviceResponse::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:action.DeviceResponse.devices)
  return devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Device >*
DeviceResponse::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:action.DeviceResponse.devices)
  return &devices_;
}
inline const ::action::Device& DeviceResponse::_internal_devices(int index) const {
  return devices_.Get(index);
}
inline const ::action::Device& DeviceResponse::devices(int index) const {
  // @@protoc_insertion_point(field_get:action.DeviceResponse.devices)
  return _internal_devices(index);
}
inline ::action::Device* DeviceResponse::_internal_add_devices() {
  return devices_.Add();
}
inline ::action::Device* DeviceResponse::add_devices() {
  ::action::Device* _add = _internal_add_devices();
  // @@protoc_insertion_point(field_add:action.DeviceResponse.devices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Device >&
DeviceResponse::devices() const {
  // @@protoc_insertion_point(field_list:action.DeviceResponse.devices)
  return devices_;
}

// -------------------------------------------------------------------

// InteractionRequest

// string DeviceID = 1;
inline void InteractionRequest::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& InteractionRequest::deviceid() const {
  // @@protoc_insertion_point(field_get:action.InteractionRequest.DeviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InteractionRequest::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.InteractionRequest.DeviceID)
}
inline std::string* InteractionRequest::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:action.InteractionRequest.DeviceID)
  return _s;
}
inline const std::string& InteractionRequest::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void InteractionRequest::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InteractionRequest::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InteractionRequest::release_deviceid() {
  // @@protoc_insertion_point(field_release:action.InteractionRequest.DeviceID)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InteractionRequest::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deviceid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deviceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.InteractionRequest.DeviceID)
}

// .action.DeviceInteractionType type = 2;
inline void InteractionRequest::clear_type() {
  type_ = 0;
}
inline ::action::DeviceInteractionType InteractionRequest::_internal_type() const {
  return static_cast< ::action::DeviceInteractionType >(type_);
}
inline ::action::DeviceInteractionType InteractionRequest::type() const {
  // @@protoc_insertion_point(field_get:action.InteractionRequest.type)
  return _internal_type();
}
inline void InteractionRequest::_internal_set_type(::action::DeviceInteractionType value) {
  
  type_ = value;
}
inline void InteractionRequest::set_type(::action::DeviceInteractionType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:action.InteractionRequest.type)
}

// -------------------------------------------------------------------

// InteractionResponse

// -------------------------------------------------------------------

// SetAttr

// string id = 1;
inline void SetAttr::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SetAttr::id() const {
  // @@protoc_insertion_point(field_get:action.SetAttr.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAttr::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.SetAttr.id)
}
inline std::string* SetAttr::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:action.SetAttr.id)
  return _s;
}
inline const std::string& SetAttr::_internal_id() const {
  return id_.Get();
}
inline void SetAttr::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetAttr::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetAttr::release_id() {
  // @@protoc_insertion_point(field_release:action.SetAttr.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetAttr::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.SetAttr.id)
}

// string attr = 2;
inline void SetAttr::clear_attr() {
  attr_.ClearToEmpty();
}
inline const std::string& SetAttr::attr() const {
  // @@protoc_insertion_point(field_get:action.SetAttr.attr)
  return _internal_attr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAttr::set_attr(ArgT0&& arg0, ArgT... args) {
 
 attr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.SetAttr.attr)
}
inline std::string* SetAttr::mutable_attr() {
  std::string* _s = _internal_mutable_attr();
  // @@protoc_insertion_point(field_mutable:action.SetAttr.attr)
  return _s;
}
inline const std::string& SetAttr::_internal_attr() const {
  return attr_.Get();
}
inline void SetAttr::_internal_set_attr(const std::string& value) {
  
  attr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetAttr::_internal_mutable_attr() {
  
  return attr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetAttr::release_attr() {
  // @@protoc_insertion_point(field_release:action.SetAttr.attr)
  return attr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetAttr::set_allocated_attr(std::string* attr) {
  if (attr != nullptr) {
    
  } else {
    
  }
  attr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (attr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    attr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.SetAttr.attr)
}

// string val = 3;
inline void SetAttr::clear_val() {
  val_.ClearToEmpty();
}
inline const std::string& SetAttr::val() const {
  // @@protoc_insertion_point(field_get:action.SetAttr.val)
  return _internal_val();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetAttr::set_val(ArgT0&& arg0, ArgT... args) {
 
 val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.SetAttr.val)
}
inline std::string* SetAttr::mutable_val() {
  std::string* _s = _internal_mutable_val();
  // @@protoc_insertion_point(field_mutable:action.SetAttr.val)
  return _s;
}
inline const std::string& SetAttr::_internal_val() const {
  return val_.Get();
}
inline void SetAttr::_internal_set_val(const std::string& value) {
  
  val_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SetAttr::_internal_mutable_val() {
  
  return val_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SetAttr::release_val() {
  // @@protoc_insertion_point(field_release:action.SetAttr.val)
  return val_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SetAttr::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    
  } else {
    
  }
  val_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), val,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (val_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    val_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.SetAttr.val)
}

// -------------------------------------------------------------------

// GetAttr

// string id = 1;
inline void GetAttr::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetAttr::id() const {
  // @@protoc_insertion_point(field_get:action.GetAttr.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAttr::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.GetAttr.id)
}
inline std::string* GetAttr::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:action.GetAttr.id)
  return _s;
}
inline const std::string& GetAttr::_internal_id() const {
  return id_.Get();
}
inline void GetAttr::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAttr::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAttr::release_id() {
  // @@protoc_insertion_point(field_release:action.GetAttr.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAttr::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.GetAttr.id)
}

// string attr = 2;
inline void GetAttr::clear_attr() {
  attr_.ClearToEmpty();
}
inline const std::string& GetAttr::attr() const {
  // @@protoc_insertion_point(field_get:action.GetAttr.attr)
  return _internal_attr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAttr::set_attr(ArgT0&& arg0, ArgT... args) {
 
 attr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.GetAttr.attr)
}
inline std::string* GetAttr::mutable_attr() {
  std::string* _s = _internal_mutable_attr();
  // @@protoc_insertion_point(field_mutable:action.GetAttr.attr)
  return _s;
}
inline const std::string& GetAttr::_internal_attr() const {
  return attr_.Get();
}
inline void GetAttr::_internal_set_attr(const std::string& value) {
  
  attr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAttr::_internal_mutable_attr() {
  
  return attr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAttr::release_attr() {
  // @@protoc_insertion_point(field_release:action.GetAttr.attr)
  return attr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAttr::set_allocated_attr(std::string* attr) {
  if (attr != nullptr) {
    
  } else {
    
  }
  attr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), attr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (attr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    attr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.GetAttr.attr)
}

// -------------------------------------------------------------------

// MoveOffset

// int64 from = 1;
inline void MoveOffset::clear_from() {
  from_ = int64_t{0};
}
inline int64_t MoveOffset::_internal_from() const {
  return from_;
}
inline int64_t MoveOffset::from() const {
  // @@protoc_insertion_point(field_get:action.MoveOffset.from)
  return _internal_from();
}
inline void MoveOffset::_internal_set_from(int64_t value) {
  
  from_ = value;
}
inline void MoveOffset::set_from(int64_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:action.MoveOffset.from)
}

// int64 to = 2;
inline void MoveOffset::clear_to() {
  to_ = int64_t{0};
}
inline int64_t MoveOffset::_internal_to() const {
  return to_;
}
inline int64_t MoveOffset::to() const {
  // @@protoc_insertion_point(field_get:action.MoveOffset.to)
  return _internal_to();
}
inline void MoveOffset::_internal_set_to(int64_t value) {
  
  to_ = value;
}
inline void MoveOffset::set_to(int64_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:action.MoveOffset.to)
}

// -------------------------------------------------------------------

// MoveElement

// string from = 1;
inline void MoveElement::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& MoveElement::from() const {
  // @@protoc_insertion_point(field_get:action.MoveElement.from)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveElement::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.MoveElement.from)
}
inline std::string* MoveElement::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:action.MoveElement.from)
  return _s;
}
inline const std::string& MoveElement::_internal_from() const {
  return from_.Get();
}
inline void MoveElement::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MoveElement::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MoveElement::release_from() {
  // @@protoc_insertion_point(field_release:action.MoveElement.from)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MoveElement::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.MoveElement.from)
}

// string to = 2;
inline void MoveElement::clear_to() {
  to_.ClearToEmpty();
}
inline const std::string& MoveElement::to() const {
  // @@protoc_insertion_point(field_get:action.MoveElement.to)
  return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveElement::set_to(ArgT0&& arg0, ArgT... args) {
 
 to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.MoveElement.to)
}
inline std::string* MoveElement::mutable_to() {
  std::string* _s = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:action.MoveElement.to)
  return _s;
}
inline const std::string& MoveElement::_internal_to() const {
  return to_.Get();
}
inline void MoveElement::_internal_set_to(const std::string& value) {
  
  to_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MoveElement::_internal_mutable_to() {
  
  return to_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MoveElement::release_to() {
  // @@protoc_insertion_point(field_release:action.MoveElement.to)
  return to_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MoveElement::set_allocated_to(std::string* to) {
  if (to != nullptr) {
    
  } else {
    
  }
  to_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), to,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (to_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    to_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.MoveElement.to)
}

// -------------------------------------------------------------------

// Touch

// string id = 1;
inline void Touch::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Touch::id() const {
  // @@protoc_insertion_point(field_get:action.Touch.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Touch::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Touch.id)
}
inline std::string* Touch::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:action.Touch.id)
  return _s;
}
inline const std::string& Touch::_internal_id() const {
  return id_.Get();
}
inline void Touch::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Touch::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Touch::release_id() {
  // @@protoc_insertion_point(field_release:action.Touch.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Touch::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Touch.id)
}

// int64 xoffset = 2;
inline void Touch::clear_xoffset() {
  xoffset_ = int64_t{0};
}
inline int64_t Touch::_internal_xoffset() const {
  return xoffset_;
}
inline int64_t Touch::xoffset() const {
  // @@protoc_insertion_point(field_get:action.Touch.xoffset)
  return _internal_xoffset();
}
inline void Touch::_internal_set_xoffset(int64_t value) {
  
  xoffset_ = value;
}
inline void Touch::set_xoffset(int64_t value) {
  _internal_set_xoffset(value);
  // @@protoc_insertion_point(field_set:action.Touch.xoffset)
}

// int64 yoffset = 3;
inline void Touch::clear_yoffset() {
  yoffset_ = int64_t{0};
}
inline int64_t Touch::_internal_yoffset() const {
  return yoffset_;
}
inline int64_t Touch::yoffset() const {
  // @@protoc_insertion_point(field_get:action.Touch.yoffset)
  return _internal_yoffset();
}
inline void Touch::_internal_set_yoffset(int64_t value) {
  
  yoffset_ = value;
}
inline void Touch::set_yoffset(int64_t value) {
  _internal_set_yoffset(value);
  // @@protoc_insertion_point(field_set:action.Touch.yoffset)
}

// -------------------------------------------------------------------

// Request

// string actionID = 1;
inline void Request::clear_actionid() {
  actionid_.ClearToEmpty();
}
inline const std::string& Request::actionid() const {
  // @@protoc_insertion_point(field_get:action.Request.actionID)
  return _internal_actionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Request::set_actionid(ArgT0&& arg0, ArgT... args) {
 
 actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Request.actionID)
}
inline std::string* Request::mutable_actionid() {
  std::string* _s = _internal_mutable_actionid();
  // @@protoc_insertion_point(field_mutable:action.Request.actionID)
  return _s;
}
inline const std::string& Request::_internal_actionid() const {
  return actionid_.Get();
}
inline void Request::_internal_set_actionid(const std::string& value) {
  
  actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_actionid() {
  
  return actionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_actionid() {
  // @@protoc_insertion_point(field_release:action.Request.actionID)
  return actionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Request::set_allocated_actionid(std::string* actionid) {
  if (actionid != nullptr) {
    
  } else {
    
  }
  actionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (actionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    actionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Request.actionID)
}

// .action.ActionType actionType = 2;
inline void Request::clear_actiontype() {
  actiontype_ = 0;
}
inline ::action::ActionType Request::_internal_actiontype() const {
  return static_cast< ::action::ActionType >(actiontype_);
}
inline ::action::ActionType Request::actiontype() const {
  // @@protoc_insertion_point(field_get:action.Request.actionType)
  return _internal_actiontype();
}
inline void Request::_internal_set_actiontype(::action::ActionType value) {
  
  actiontype_ = value;
}
inline void Request::set_actiontype(::action::ActionType value) {
  _internal_set_actiontype(value);
  // @@protoc_insertion_point(field_set:action.Request.actionType)
}

// string id = 3;
inline bool Request::_internal_has_id() const {
  return payload_case() == kId;
}
inline bool Request::has_id() const {
  return _internal_has_id();
}
inline void Request::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void Request::clear_id() {
  if (_internal_has_id()) {
    payload_.id_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_payload();
  }
}
inline const std::string& Request::id() const {
  // @@protoc_insertion_point(field_get:action.Request.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline void Request::set_id(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_id()) {
    clear_payload();
    set_has_id();
    payload_.id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Request.id)
}
inline std::string* Request::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:action.Request.id)
  return _s;
}
inline const std::string& Request::_internal_id() const {
  if (_internal_has_id()) {
    return payload_.id_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Request::_internal_set_id(const std::string& value) {
  if (!_internal_has_id()) {
    clear_payload();
    set_has_id();
    payload_.id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_id() {
  if (!_internal_has_id()) {
    clear_payload();
    set_has_id();
    payload_.id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return payload_.id_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_id() {
  // @@protoc_insertion_point(field_release:action.Request.id)
  if (_internal_has_id()) {
    clear_has_payload();
    return payload_.id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Request::set_allocated_id(std::string* id) {
  if (has_payload()) {
    clear_payload();
  }
  if (id != nullptr) {
    set_has_id();
    payload_.id_.UnsafeSetDefault(id);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(id);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:action.Request.id)
}

// string data = 4;
inline bool Request::_internal_has_data() const {
  return payload_case() == kData;
}
inline bool Request::has_data() const {
  return _internal_has_data();
}
inline void Request::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Request::clear_data() {
  if (_internal_has_data()) {
    payload_.data_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_payload();
  }
}
inline const std::string& Request::data() const {
  // @@protoc_insertion_point(field_get:action.Request.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline void Request::set_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Request.data)
}
inline std::string* Request::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:action.Request.data)
  return _s;
}
inline const std::string& Request::_internal_data() const {
  if (_internal_has_data()) {
    return payload_.data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Request::_internal_set_data(const std::string& value) {
  if (!_internal_has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Request::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return payload_.data_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Request::release_data() {
  // @@protoc_insertion_point(field_release:action.Request.data)
  if (_internal_has_data()) {
    clear_has_payload();
    return payload_.data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Request::set_allocated_data(std::string* data) {
  if (has_payload()) {
    clear_payload();
  }
  if (data != nullptr) {
    set_has_data();
    payload_.data_.UnsafeSetDefault(data);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(data);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:action.Request.data)
}

// .action.SetAttr setAttr = 5;
inline bool Request::_internal_has_setattr() const {
  return payload_case() == kSetAttr;
}
inline bool Request::has_setattr() const {
  return _internal_has_setattr();
}
inline void Request::set_has_setattr() {
  _oneof_case_[0] = kSetAttr;
}
inline void Request::clear_setattr() {
  if (_internal_has_setattr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.setattr_;
    }
    clear_has_payload();
  }
}
inline ::action::SetAttr* Request::release_setattr() {
  // @@protoc_insertion_point(field_release:action.Request.setAttr)
  if (_internal_has_setattr()) {
    clear_has_payload();
      ::action::SetAttr* temp = payload_.setattr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.setattr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::SetAttr& Request::_internal_setattr() const {
  return _internal_has_setattr()
      ? *payload_.setattr_
      : reinterpret_cast< ::action::SetAttr&>(::action::_SetAttr_default_instance_);
}
inline const ::action::SetAttr& Request::setattr() const {
  // @@protoc_insertion_point(field_get:action.Request.setAttr)
  return _internal_setattr();
}
inline ::action::SetAttr* Request::unsafe_arena_release_setattr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Request.setAttr)
  if (_internal_has_setattr()) {
    clear_has_payload();
    ::action::SetAttr* temp = payload_.setattr_;
    payload_.setattr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_setattr(::action::SetAttr* setattr) {
  clear_payload();
  if (setattr) {
    set_has_setattr();
    payload_.setattr_ = setattr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Request.setAttr)
}
inline ::action::SetAttr* Request::_internal_mutable_setattr() {
  if (!_internal_has_setattr()) {
    clear_payload();
    set_has_setattr();
    payload_.setattr_ = CreateMaybeMessage< ::action::SetAttr >(GetArenaForAllocation());
  }
  return payload_.setattr_;
}
inline ::action::SetAttr* Request::mutable_setattr() {
  ::action::SetAttr* _msg = _internal_mutable_setattr();
  // @@protoc_insertion_point(field_mutable:action.Request.setAttr)
  return _msg;
}

// .action.GetAttr getAttr = 6;
inline bool Request::_internal_has_getattr() const {
  return payload_case() == kGetAttr;
}
inline bool Request::has_getattr() const {
  return _internal_has_getattr();
}
inline void Request::set_has_getattr() {
  _oneof_case_[0] = kGetAttr;
}
inline void Request::clear_getattr() {
  if (_internal_has_getattr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.getattr_;
    }
    clear_has_payload();
  }
}
inline ::action::GetAttr* Request::release_getattr() {
  // @@protoc_insertion_point(field_release:action.Request.getAttr)
  if (_internal_has_getattr()) {
    clear_has_payload();
      ::action::GetAttr* temp = payload_.getattr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.getattr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::GetAttr& Request::_internal_getattr() const {
  return _internal_has_getattr()
      ? *payload_.getattr_
      : reinterpret_cast< ::action::GetAttr&>(::action::_GetAttr_default_instance_);
}
inline const ::action::GetAttr& Request::getattr() const {
  // @@protoc_insertion_point(field_get:action.Request.getAttr)
  return _internal_getattr();
}
inline ::action::GetAttr* Request::unsafe_arena_release_getattr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Request.getAttr)
  if (_internal_has_getattr()) {
    clear_has_payload();
    ::action::GetAttr* temp = payload_.getattr_;
    payload_.getattr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_getattr(::action::GetAttr* getattr) {
  clear_payload();
  if (getattr) {
    set_has_getattr();
    payload_.getattr_ = getattr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Request.getAttr)
}
inline ::action::GetAttr* Request::_internal_mutable_getattr() {
  if (!_internal_has_getattr()) {
    clear_payload();
    set_has_getattr();
    payload_.getattr_ = CreateMaybeMessage< ::action::GetAttr >(GetArenaForAllocation());
  }
  return payload_.getattr_;
}
inline ::action::GetAttr* Request::mutable_getattr() {
  ::action::GetAttr* _msg = _internal_mutable_getattr();
  // @@protoc_insertion_point(field_mutable:action.Request.getAttr)
  return _msg;
}

// .action.MoveOffset moveOffset = 7;
inline bool Request::_internal_has_moveoffset() const {
  return payload_case() == kMoveOffset;
}
inline bool Request::has_moveoffset() const {
  return _internal_has_moveoffset();
}
inline void Request::set_has_moveoffset() {
  _oneof_case_[0] = kMoveOffset;
}
inline void Request::clear_moveoffset() {
  if (_internal_has_moveoffset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.moveoffset_;
    }
    clear_has_payload();
  }
}
inline ::action::MoveOffset* Request::release_moveoffset() {
  // @@protoc_insertion_point(field_release:action.Request.moveOffset)
  if (_internal_has_moveoffset()) {
    clear_has_payload();
      ::action::MoveOffset* temp = payload_.moveoffset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.moveoffset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::MoveOffset& Request::_internal_moveoffset() const {
  return _internal_has_moveoffset()
      ? *payload_.moveoffset_
      : reinterpret_cast< ::action::MoveOffset&>(::action::_MoveOffset_default_instance_);
}
inline const ::action::MoveOffset& Request::moveoffset() const {
  // @@protoc_insertion_point(field_get:action.Request.moveOffset)
  return _internal_moveoffset();
}
inline ::action::MoveOffset* Request::unsafe_arena_release_moveoffset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Request.moveOffset)
  if (_internal_has_moveoffset()) {
    clear_has_payload();
    ::action::MoveOffset* temp = payload_.moveoffset_;
    payload_.moveoffset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_moveoffset(::action::MoveOffset* moveoffset) {
  clear_payload();
  if (moveoffset) {
    set_has_moveoffset();
    payload_.moveoffset_ = moveoffset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Request.moveOffset)
}
inline ::action::MoveOffset* Request::_internal_mutable_moveoffset() {
  if (!_internal_has_moveoffset()) {
    clear_payload();
    set_has_moveoffset();
    payload_.moveoffset_ = CreateMaybeMessage< ::action::MoveOffset >(GetArenaForAllocation());
  }
  return payload_.moveoffset_;
}
inline ::action::MoveOffset* Request::mutable_moveoffset() {
  ::action::MoveOffset* _msg = _internal_mutable_moveoffset();
  // @@protoc_insertion_point(field_mutable:action.Request.moveOffset)
  return _msg;
}

// .action.Touch touch = 8;
inline bool Request::_internal_has_touch() const {
  return payload_case() == kTouch;
}
inline bool Request::has_touch() const {
  return _internal_has_touch();
}
inline void Request::set_has_touch() {
  _oneof_case_[0] = kTouch;
}
inline void Request::clear_touch() {
  if (_internal_has_touch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.touch_;
    }
    clear_has_payload();
  }
}
inline ::action::Touch* Request::release_touch() {
  // @@protoc_insertion_point(field_release:action.Request.touch)
  if (_internal_has_touch()) {
    clear_has_payload();
      ::action::Touch* temp = payload_.touch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.touch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::Touch& Request::_internal_touch() const {
  return _internal_has_touch()
      ? *payload_.touch_
      : reinterpret_cast< ::action::Touch&>(::action::_Touch_default_instance_);
}
inline const ::action::Touch& Request::touch() const {
  // @@protoc_insertion_point(field_get:action.Request.touch)
  return _internal_touch();
}
inline ::action::Touch* Request::unsafe_arena_release_touch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Request.touch)
  if (_internal_has_touch()) {
    clear_has_payload();
    ::action::Touch* temp = payload_.touch_;
    payload_.touch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_touch(::action::Touch* touch) {
  clear_payload();
  if (touch) {
    set_has_touch();
    payload_.touch_ = touch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Request.touch)
}
inline ::action::Touch* Request::_internal_mutable_touch() {
  if (!_internal_has_touch()) {
    clear_payload();
    set_has_touch();
    payload_.touch_ = CreateMaybeMessage< ::action::Touch >(GetArenaForAllocation());
  }
  return payload_.touch_;
}
inline ::action::Touch* Request::mutable_touch() {
  ::action::Touch* _msg = _internal_mutable_touch();
  // @@protoc_insertion_point(field_mutable:action.Request.touch)
  return _msg;
}

// .action.MoveElement moveElement = 9;
inline bool Request::_internal_has_moveelement() const {
  return payload_case() == kMoveElement;
}
inline bool Request::has_moveelement() const {
  return _internal_has_moveelement();
}
inline void Request::set_has_moveelement() {
  _oneof_case_[0] = kMoveElement;
}
inline void Request::clear_moveelement() {
  if (_internal_has_moveelement()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.moveelement_;
    }
    clear_has_payload();
  }
}
inline ::action::MoveElement* Request::release_moveelement() {
  // @@protoc_insertion_point(field_release:action.Request.moveElement)
  if (_internal_has_moveelement()) {
    clear_has_payload();
      ::action::MoveElement* temp = payload_.moveelement_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.moveelement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::MoveElement& Request::_internal_moveelement() const {
  return _internal_has_moveelement()
      ? *payload_.moveelement_
      : reinterpret_cast< ::action::MoveElement&>(::action::_MoveElement_default_instance_);
}
inline const ::action::MoveElement& Request::moveelement() const {
  // @@protoc_insertion_point(field_get:action.Request.moveElement)
  return _internal_moveelement();
}
inline ::action::MoveElement* Request::unsafe_arena_release_moveelement() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Request.moveElement)
  if (_internal_has_moveelement()) {
    clear_has_payload();
    ::action::MoveElement* temp = payload_.moveelement_;
    payload_.moveelement_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_moveelement(::action::MoveElement* moveelement) {
  clear_payload();
  if (moveelement) {
    set_has_moveelement();
    payload_.moveelement_ = moveelement;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Request.moveElement)
}
inline ::action::MoveElement* Request::_internal_mutable_moveelement() {
  if (!_internal_has_moveelement()) {
    clear_payload();
    set_has_moveelement();
    payload_.moveelement_ = CreateMaybeMessage< ::action::MoveElement >(GetArenaForAllocation());
  }
  return payload_.moveelement_;
}
inline ::action::MoveElement* Request::mutable_moveelement() {
  ::action::MoveElement* _msg = _internal_mutable_moveelement();
  // @@protoc_insertion_point(field_mutable:action.Request.moveElement)
  return _msg;
}

// .action.Test test = 10;
inline bool Request::_internal_has_test() const {
  return payload_case() == kTest;
}
inline bool Request::has_test() const {
  return _internal_has_test();
}
inline void Request::set_has_test() {
  _oneof_case_[0] = kTest;
}
inline void Request::clear_test() {
  if (_internal_has_test()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.test_;
    }
    clear_has_payload();
  }
}
inline ::action::Test* Request::release_test() {
  // @@protoc_insertion_point(field_release:action.Request.test)
  if (_internal_has_test()) {
    clear_has_payload();
      ::action::Test* temp = payload_.test_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::Test& Request::_internal_test() const {
  return _internal_has_test()
      ? *payload_.test_
      : reinterpret_cast< ::action::Test&>(::action::_Test_default_instance_);
}
inline const ::action::Test& Request::test() const {
  // @@protoc_insertion_point(field_get:action.Request.test)
  return _internal_test();
}
inline ::action::Test* Request::unsafe_arena_release_test() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Request.test)
  if (_internal_has_test()) {
    clear_has_payload();
    ::action::Test* temp = payload_.test_;
    payload_.test_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_test(::action::Test* test) {
  clear_payload();
  if (test) {
    set_has_test();
    payload_.test_ = test;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Request.test)
}
inline ::action::Test* Request::_internal_mutable_test() {
  if (!_internal_has_test()) {
    clear_payload();
    set_has_test();
    payload_.test_ = CreateMaybeMessage< ::action::Test >(GetArenaForAllocation());
  }
  return payload_.test_;
}
inline ::action::Test* Request::mutable_test() {
  ::action::Test* _msg = _internal_mutable_test();
  // @@protoc_insertion_point(field_mutable:action.Request.test)
  return _msg;
}

inline bool Request::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Request::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Request::PayloadCase Request::payload_case() const {
  return Request::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Connect

// string customerId = 1;
inline void Connect::clear_customerid() {
  customerid_.ClearToEmpty();
}
inline const std::string& Connect::customerid() const {
  // @@protoc_insertion_point(field_get:action.Connect.customerId)
  return _internal_customerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_customerid(ArgT0&& arg0, ArgT... args) {
 
 customerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Connect.customerId)
}
inline std::string* Connect::mutable_customerid() {
  std::string* _s = _internal_mutable_customerid();
  // @@protoc_insertion_point(field_mutable:action.Connect.customerId)
  return _s;
}
inline const std::string& Connect::_internal_customerid() const {
  return customerid_.Get();
}
inline void Connect::_internal_set_customerid(const std::string& value) {
  
  customerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_customerid() {
  
  return customerid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connect::release_customerid() {
  // @@protoc_insertion_point(field_release:action.Connect.customerId)
  return customerid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connect::set_allocated_customerid(std::string* customerid) {
  if (customerid != nullptr) {
    
  } else {
    
  }
  customerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), customerid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (customerid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    customerid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Connect.customerId)
}

// string appID = 2;
inline void Connect::clear_appid() {
  appid_.ClearToEmpty();
}
inline const std::string& Connect::appid() const {
  // @@protoc_insertion_point(field_get:action.Connect.appID)
  return _internal_appid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_appid(ArgT0&& arg0, ArgT... args) {
 
 appid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Connect.appID)
}
inline std::string* Connect::mutable_appid() {
  std::string* _s = _internal_mutable_appid();
  // @@protoc_insertion_point(field_mutable:action.Connect.appID)
  return _s;
}
inline const std::string& Connect::_internal_appid() const {
  return appid_.Get();
}
inline void Connect::_internal_set_appid(const std::string& value) {
  
  appid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_appid() {
  
  return appid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connect::release_appid() {
  // @@protoc_insertion_point(field_release:action.Connect.appID)
  return appid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connect::set_allocated_appid(std::string* appid) {
  if (appid != nullptr) {
    
  } else {
    
  }
  appid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), appid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (appid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    appid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Connect.appID)
}

// .action.AppType appType = 3;
inline void Connect::clear_apptype() {
  apptype_ = 0;
}
inline ::action::AppType Connect::_internal_apptype() const {
  return static_cast< ::action::AppType >(apptype_);
}
inline ::action::AppType Connect::apptype() const {
  // @@protoc_insertion_point(field_get:action.Connect.appType)
  return _internal_apptype();
}
inline void Connect::_internal_set_apptype(::action::AppType value) {
  
  apptype_ = value;
}
inline void Connect::set_apptype(::action::AppType value) {
  _internal_set_apptype(value);
  // @@protoc_insertion_point(field_set:action.Connect.appType)
}

// string deviceID = 4;
inline void Connect::clear_deviceid() {
  deviceid_.ClearToEmpty();
}
inline const std::string& Connect::deviceid() const {
  // @@protoc_insertion_point(field_get:action.Connect.deviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Connect.deviceID)
}
inline std::string* Connect::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:action.Connect.deviceID)
  return _s;
}
inline const std::string& Connect::_internal_deviceid() const {
  return deviceid_.Get();
}
inline void Connect::_internal_set_deviceid(const std::string& value) {
  
  deviceid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_deviceid() {
  
  return deviceid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connect::release_deviceid() {
  // @@protoc_insertion_point(field_release:action.Connect.deviceID)
  return deviceid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connect::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  deviceid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deviceid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deviceid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deviceid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Connect.deviceID)
}

// string sessionID = 5;
inline void Connect::clear_sessionid() {
  sessionid_.ClearToEmpty();
}
inline const std::string& Connect::sessionid() const {
  // @@protoc_insertion_point(field_get:action.Connect.sessionID)
  return _internal_sessionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_sessionid(ArgT0&& arg0, ArgT... args) {
 
 sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Connect.sessionID)
}
inline std::string* Connect::mutable_sessionid() {
  std::string* _s = _internal_mutable_sessionid();
  // @@protoc_insertion_point(field_mutable:action.Connect.sessionID)
  return _s;
}
inline const std::string& Connect::_internal_sessionid() const {
  return sessionid_.Get();
}
inline void Connect::_internal_set_sessionid(const std::string& value) {
  
  sessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_sessionid() {
  
  return sessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connect::release_sessionid() {
  // @@protoc_insertion_point(field_release:action.Connect.sessionID)
  return sessionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connect::set_allocated_sessionid(std::string* sessionid) {
  if (sessionid != nullptr) {
    
  } else {
    
  }
  sessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sessionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sessionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sessionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Connect.sessionID)
}

// string version = 6;
inline void Connect::clear_version() {
  version_.ClearToEmpty();
}
inline const std::string& Connect::version() const {
  // @@protoc_insertion_point(field_get:action.Connect.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Connect::set_version(ArgT0&& arg0, ArgT... args) {
 
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Connect.version)
}
inline std::string* Connect::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:action.Connect.version)
  return _s;
}
inline const std::string& Connect::_internal_version() const {
  return version_.Get();
}
inline void Connect::_internal_set_version(const std::string& value) {
  
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Connect::_internal_mutable_version() {
  
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Connect::release_version() {
  // @@protoc_insertion_point(field_release:action.Connect.version)
  return version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Connect::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Connect.version)
}

// -------------------------------------------------------------------

// Screenshot

// bytes sceengraph = 1;
inline void Screenshot::clear_sceengraph() {
  sceengraph_.ClearToEmpty();
}
inline const std::string& Screenshot::sceengraph() const {
  // @@protoc_insertion_point(field_get:action.Screenshot.sceengraph)
  return _internal_sceengraph();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Screenshot::set_sceengraph(ArgT0&& arg0, ArgT... args) {
 
 sceengraph_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Screenshot.sceengraph)
}
inline std::string* Screenshot::mutable_sceengraph() {
  std::string* _s = _internal_mutable_sceengraph();
  // @@protoc_insertion_point(field_mutable:action.Screenshot.sceengraph)
  return _s;
}
inline const std::string& Screenshot::_internal_sceengraph() const {
  return sceengraph_.Get();
}
inline void Screenshot::_internal_set_sceengraph(const std::string& value) {
  
  sceengraph_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Screenshot::_internal_mutable_sceengraph() {
  
  return sceengraph_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Screenshot::release_sceengraph() {
  // @@protoc_insertion_point(field_release:action.Screenshot.sceengraph)
  return sceengraph_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Screenshot::set_allocated_sceengraph(std::string* sceengraph) {
  if (sceengraph != nullptr) {
    
  } else {
    
  }
  sceengraph_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sceengraph,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sceengraph_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sceengraph_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Screenshot.sceengraph)
}

// bytes screenshot = 2;
inline void Screenshot::clear_screenshot() {
  screenshot_.ClearToEmpty();
}
inline const std::string& Screenshot::screenshot() const {
  // @@protoc_insertion_point(field_get:action.Screenshot.screenshot)
  return _internal_screenshot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Screenshot::set_screenshot(ArgT0&& arg0, ArgT... args) {
 
 screenshot_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Screenshot.screenshot)
}
inline std::string* Screenshot::mutable_screenshot() {
  std::string* _s = _internal_mutable_screenshot();
  // @@protoc_insertion_point(field_mutable:action.Screenshot.screenshot)
  return _s;
}
inline const std::string& Screenshot::_internal_screenshot() const {
  return screenshot_.Get();
}
inline void Screenshot::_internal_set_screenshot(const std::string& value) {
  
  screenshot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Screenshot::_internal_mutable_screenshot() {
  
  return screenshot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Screenshot::release_screenshot() {
  // @@protoc_insertion_point(field_release:action.Screenshot.screenshot)
  return screenshot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Screenshot::set_allocated_screenshot(std::string* screenshot) {
  if (screenshot != nullptr) {
    
  } else {
    
  }
  screenshot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), screenshot,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Screenshot.screenshot)
}

// .action.ContentType contentType = 3;
inline void Screenshot::clear_contenttype() {
  contenttype_ = 0;
}
inline ::action::ContentType Screenshot::_internal_contenttype() const {
  return static_cast< ::action::ContentType >(contenttype_);
}
inline ::action::ContentType Screenshot::contenttype() const {
  // @@protoc_insertion_point(field_get:action.Screenshot.contentType)
  return _internal_contenttype();
}
inline void Screenshot::_internal_set_contenttype(::action::ContentType value) {
  
  contenttype_ = value;
}
inline void Screenshot::set_contenttype(::action::ContentType value) {
  _internal_set_contenttype(value);
  // @@protoc_insertion_point(field_set:action.Screenshot.contentType)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Test

// string assembly = 1;
inline void Test::clear_assembly() {
  assembly_.ClearToEmpty();
}
inline const std::string& Test::assembly() const {
  // @@protoc_insertion_point(field_get:action.Test.assembly)
  return _internal_assembly();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Test::set_assembly(ArgT0&& arg0, ArgT... args) {
 
 assembly_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Test.assembly)
}
inline std::string* Test::mutable_assembly() {
  std::string* _s = _internal_mutable_assembly();
  // @@protoc_insertion_point(field_mutable:action.Test.assembly)
  return _s;
}
inline const std::string& Test::_internal_assembly() const {
  return assembly_.Get();
}
inline void Test::_internal_set_assembly(const std::string& value) {
  
  assembly_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Test::_internal_mutable_assembly() {
  
  return assembly_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Test::release_assembly() {
  // @@protoc_insertion_point(field_release:action.Test.assembly)
  return assembly_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Test::set_allocated_assembly(std::string* assembly) {
  if (assembly != nullptr) {
    
  } else {
    
  }
  assembly_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assembly,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (assembly_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    assembly_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Test.assembly)
}

// string class = 2;
inline void Test::clear_class_() {
  class__.ClearToEmpty();
}
inline const std::string& Test::class_() const {
  // @@protoc_insertion_point(field_get:action.Test.class)
  return _internal_class_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Test::set_class_(ArgT0&& arg0, ArgT... args) {
 
 class__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Test.class)
}
inline std::string* Test::mutable_class_() {
  std::string* _s = _internal_mutable_class_();
  // @@protoc_insertion_point(field_mutable:action.Test.class)
  return _s;
}
inline const std::string& Test::_internal_class_() const {
  return class__.Get();
}
inline void Test::_internal_set_class_(const std::string& value) {
  
  class__.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Test::_internal_mutable_class_() {
  
  return class__.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Test::release_class_() {
  // @@protoc_insertion_point(field_release:action.Test.class)
  return class__.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Test::set_allocated_class_(std::string* class_) {
  if (class_ != nullptr) {
    
  } else {
    
  }
  class__.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), class_,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (class__.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    class__.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Test.class)
}

// string method = 3;
inline void Test::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& Test::method() const {
  // @@protoc_insertion_point(field_get:action.Test.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Test::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Test.method)
}
inline std::string* Test::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:action.Test.method)
  return _s;
}
inline const std::string& Test::_internal_method() const {
  return method_.Get();
}
inline void Test::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Test::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Test::release_method() {
  // @@protoc_insertion_point(field_release:action.Test.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Test::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    method_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Test.method)
}

// map<string, string> parameter = 4;
inline int Test::_internal_parameter_size() const {
  return parameter_.size();
}
inline int Test::parameter_size() const {
  return _internal_parameter_size();
}
inline void Test::clear_parameter() {
  parameter_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Test::_internal_parameter() const {
  return parameter_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Test::parameter() const {
  // @@protoc_insertion_point(field_map:action.Test.parameter)
  return _internal_parameter();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Test::_internal_mutable_parameter() {
  return parameter_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Test::mutable_parameter() {
  // @@protoc_insertion_point(field_mutable_map:action.Test.parameter)
  return _internal_mutable_parameter();
}

// repeated string categories = 5;
inline int Test::_internal_categories_size() const {
  return categories_.size();
}
inline int Test::categories_size() const {
  return _internal_categories_size();
}
inline void Test::clear_categories() {
  categories_.Clear();
}
inline std::string* Test::add_categories() {
  std::string* _s = _internal_add_categories();
  // @@protoc_insertion_point(field_add_mutable:action.Test.categories)
  return _s;
}
inline const std::string& Test::_internal_categories(int index) const {
  return categories_.Get(index);
}
inline const std::string& Test::categories(int index) const {
  // @@protoc_insertion_point(field_get:action.Test.categories)
  return _internal_categories(index);
}
inline std::string* Test::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:action.Test.categories)
  return categories_.Mutable(index);
}
inline void Test::set_categories(int index, const std::string& value) {
  categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:action.Test.categories)
}
inline void Test::set_categories(int index, std::string&& value) {
  categories_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:action.Test.categories)
}
inline void Test::set_categories(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:action.Test.categories)
}
inline void Test::set_categories(int index, const char* value, size_t size) {
  categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:action.Test.categories)
}
inline std::string* Test::_internal_add_categories() {
  return categories_.Add();
}
inline void Test::add_categories(const std::string& value) {
  categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:action.Test.categories)
}
inline void Test::add_categories(std::string&& value) {
  categories_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:action.Test.categories)
}
inline void Test::add_categories(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:action.Test.categories)
}
inline void Test::add_categories(const char* value, size_t size) {
  categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:action.Test.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Test::categories() const {
  // @@protoc_insertion_point(field_list:action.Test.categories)
  return categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Test::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:action.Test.categories)
  return &categories_;
}

// -------------------------------------------------------------------

// Tests

// repeated .action.Test tests = 1;
inline int Tests::_internal_tests_size() const {
  return tests_.size();
}
inline int Tests::tests_size() const {
  return _internal_tests_size();
}
inline void Tests::clear_tests() {
  tests_.Clear();
}
inline ::action::Test* Tests::mutable_tests(int index) {
  // @@protoc_insertion_point(field_mutable:action.Tests.tests)
  return tests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Test >*
Tests::mutable_tests() {
  // @@protoc_insertion_point(field_mutable_list:action.Tests.tests)
  return &tests_;
}
inline const ::action::Test& Tests::_internal_tests(int index) const {
  return tests_.Get(index);
}
inline const ::action::Test& Tests::tests(int index) const {
  // @@protoc_insertion_point(field_get:action.Tests.tests)
  return _internal_tests(index);
}
inline ::action::Test* Tests::_internal_add_tests() {
  return tests_.Add();
}
inline ::action::Test* Tests::add_tests() {
  ::action::Test* _add = _internal_add_tests();
  // @@protoc_insertion_point(field_add:action.Tests.tests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::action::Test >&
Tests::tests() const {
  // @@protoc_insertion_point(field_list:action.Tests.tests)
  return tests_;
}

// -------------------------------------------------------------------

// LogData

// .action.LogType type = 1;
inline void LogData::clear_type() {
  type_ = 0;
}
inline ::action::LogType LogData::_internal_type() const {
  return static_cast< ::action::LogType >(type_);
}
inline ::action::LogType LogData::type() const {
  // @@protoc_insertion_point(field_get:action.LogData.type)
  return _internal_type();
}
inline void LogData::_internal_set_type(::action::LogType value) {
  
  type_ = value;
}
inline void LogData::set_type(::action::LogType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:action.LogData.type)
}

// .action.LogLevel level = 2;
inline void LogData::clear_level() {
  level_ = 0;
}
inline ::action::LogLevel LogData::_internal_level() const {
  return static_cast< ::action::LogLevel >(level_);
}
inline ::action::LogLevel LogData::level() const {
  // @@protoc_insertion_point(field_get:action.LogData.level)
  return _internal_level();
}
inline void LogData::_internal_set_level(::action::LogLevel value) {
  
  level_ = value;
}
inline void LogData::set_level(::action::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:action.LogData.level)
}

// string message = 3;
inline void LogData::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& LogData::message() const {
  // @@protoc_insertion_point(field_get:action.LogData.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogData::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.LogData.message)
}
inline std::string* LogData::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:action.LogData.message)
  return _s;
}
inline const std::string& LogData::_internal_message() const {
  return message_.Get();
}
inline void LogData::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LogData::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LogData::release_message() {
  // @@protoc_insertion_point(field_release:action.LogData.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LogData::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.LogData.message)
}

// -------------------------------------------------------------------

// TestDetails

// int32 timeout = 1;
inline void TestDetails::clear_timeout() {
  timeout_ = 0;
}
inline int32_t TestDetails::_internal_timeout() const {
  return timeout_;
}
inline int32_t TestDetails::timeout() const {
  // @@protoc_insertion_point(field_get:action.TestDetails.timeout)
  return _internal_timeout();
}
inline void TestDetails::_internal_set_timeout(int32_t value) {
  
  timeout_ = value;
}
inline void TestDetails::set_timeout(int32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:action.TestDetails.timeout)
}

// repeated string categories = 2;
inline int TestDetails::_internal_categories_size() const {
  return categories_.size();
}
inline int TestDetails::categories_size() const {
  return _internal_categories_size();
}
inline void TestDetails::clear_categories() {
  categories_.Clear();
}
inline std::string* TestDetails::add_categories() {
  std::string* _s = _internal_add_categories();
  // @@protoc_insertion_point(field_add_mutable:action.TestDetails.categories)
  return _s;
}
inline const std::string& TestDetails::_internal_categories(int index) const {
  return categories_.Get(index);
}
inline const std::string& TestDetails::categories(int index) const {
  // @@protoc_insertion_point(field_get:action.TestDetails.categories)
  return _internal_categories(index);
}
inline std::string* TestDetails::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:action.TestDetails.categories)
  return categories_.Mutable(index);
}
inline void TestDetails::set_categories(int index, const std::string& value) {
  categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:action.TestDetails.categories)
}
inline void TestDetails::set_categories(int index, std::string&& value) {
  categories_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:action.TestDetails.categories)
}
inline void TestDetails::set_categories(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:action.TestDetails.categories)
}
inline void TestDetails::set_categories(int index, const char* value, size_t size) {
  categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:action.TestDetails.categories)
}
inline std::string* TestDetails::_internal_add_categories() {
  return categories_.Add();
}
inline void TestDetails::add_categories(const std::string& value) {
  categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:action.TestDetails.categories)
}
inline void TestDetails::add_categories(std::string&& value) {
  categories_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:action.TestDetails.categories)
}
inline void TestDetails::add_categories(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:action.TestDetails.categories)
}
inline void TestDetails::add_categories(const char* value, size_t size) {
  categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:action.TestDetails.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TestDetails::categories() const {
  // @@protoc_insertion_point(field_list:action.TestDetails.categories)
  return categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TestDetails::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:action.TestDetails.categories)
  return &categories_;
}

// -------------------------------------------------------------------

// PerformanceData

// string checkpoint = 1;
inline void PerformanceData::clear_checkpoint() {
  checkpoint_.ClearToEmpty();
}
inline const std::string& PerformanceData::checkpoint() const {
  // @@protoc_insertion_point(field_get:action.PerformanceData.checkpoint)
  return _internal_checkpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PerformanceData::set_checkpoint(ArgT0&& arg0, ArgT... args) {
 
 checkpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.PerformanceData.checkpoint)
}
inline std::string* PerformanceData::mutable_checkpoint() {
  std::string* _s = _internal_mutable_checkpoint();
  // @@protoc_insertion_point(field_mutable:action.PerformanceData.checkpoint)
  return _s;
}
inline const std::string& PerformanceData::_internal_checkpoint() const {
  return checkpoint_.Get();
}
inline void PerformanceData::_internal_set_checkpoint(const std::string& value) {
  
  checkpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PerformanceData::_internal_mutable_checkpoint() {
  
  return checkpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PerformanceData::release_checkpoint() {
  // @@protoc_insertion_point(field_release:action.PerformanceData.checkpoint)
  return checkpoint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PerformanceData::set_allocated_checkpoint(std::string* checkpoint) {
  if (checkpoint != nullptr) {
    
  } else {
    
  }
  checkpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), checkpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (checkpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    checkpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.PerformanceData.checkpoint)
}

// float cpu = 2;
inline void PerformanceData::clear_cpu() {
  cpu_ = 0;
}
inline float PerformanceData::_internal_cpu() const {
  return cpu_;
}
inline float PerformanceData::cpu() const {
  // @@protoc_insertion_point(field_get:action.PerformanceData.cpu)
  return _internal_cpu();
}
inline void PerformanceData::_internal_set_cpu(float value) {
  
  cpu_ = value;
}
inline void PerformanceData::set_cpu(float value) {
  _internal_set_cpu(value);
  // @@protoc_insertion_point(field_set:action.PerformanceData.cpu)
}

// float memory = 3;
inline void PerformanceData::clear_memory() {
  memory_ = 0;
}
inline float PerformanceData::_internal_memory() const {
  return memory_;
}
inline float PerformanceData::memory() const {
  // @@protoc_insertion_point(field_get:action.PerformanceData.memory)
  return _internal_memory();
}
inline void PerformanceData::_internal_set_memory(float value) {
  
  memory_ = value;
}
inline void PerformanceData::set_memory(float value) {
  _internal_set_memory(value);
  // @@protoc_insertion_point(field_set:action.PerformanceData.memory)
}

// float fps = 4;
inline void PerformanceData::clear_fps() {
  fps_ = 0;
}
inline float PerformanceData::_internal_fps() const {
  return fps_;
}
inline float PerformanceData::fps() const {
  // @@protoc_insertion_point(field_get:action.PerformanceData.fps)
  return _internal_fps();
}
inline void PerformanceData::_internal_set_fps(float value) {
  
  fps_ = value;
}
inline void PerformanceData::set_fps(float value) {
  _internal_set_fps(value);
  // @@protoc_insertion_point(field_set:action.PerformanceData.fps)
}

// -------------------------------------------------------------------

// Response

// string actionID = 1;
inline void Response::clear_actionid() {
  actionid_.ClearToEmpty();
}
inline const std::string& Response::actionid() const {
  // @@protoc_insertion_point(field_get:action.Response.actionID)
  return _internal_actionid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Response::set_actionid(ArgT0&& arg0, ArgT... args) {
 
 actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Response.actionID)
}
inline std::string* Response::mutable_actionid() {
  std::string* _s = _internal_mutable_actionid();
  // @@protoc_insertion_point(field_mutable:action.Response.actionID)
  return _s;
}
inline const std::string& Response::_internal_actionid() const {
  return actionid_.Get();
}
inline void Response::_internal_set_actionid(const std::string& value) {
  
  actionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_actionid() {
  
  return actionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Response::release_actionid() {
  // @@protoc_insertion_point(field_release:action.Response.actionID)
  return actionid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Response::set_allocated_actionid(std::string* actionid) {
  if (actionid != nullptr) {
    
  } else {
    
  }
  actionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), actionid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (actionid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    actionid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:action.Response.actionID)
}

// .action.ActionType actionType = 2;
inline void Response::clear_actiontype() {
  actiontype_ = 0;
}
inline ::action::ActionType Response::_internal_actiontype() const {
  return static_cast< ::action::ActionType >(actiontype_);
}
inline ::action::ActionType Response::actiontype() const {
  // @@protoc_insertion_point(field_get:action.Response.actionType)
  return _internal_actiontype();
}
inline void Response::_internal_set_actiontype(::action::ActionType value) {
  
  actiontype_ = value;
}
inline void Response::set_actiontype(::action::ActionType value) {
  _internal_set_actiontype(value);
  // @@protoc_insertion_point(field_set:action.Response.actionType)
}

// bool success = 3;
inline void Response::clear_success() {
  success_ = false;
}
inline bool Response::_internal_success() const {
  return success_;
}
inline bool Response::success() const {
  // @@protoc_insertion_point(field_get:action.Response.success)
  return _internal_success();
}
inline void Response::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void Response::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:action.Response.success)
}

// bool visible = 4;
inline bool Response::_internal_has_visible() const {
  return payload_case() == kVisible;
}
inline bool Response::has_visible() const {
  return _internal_has_visible();
}
inline void Response::set_has_visible() {
  _oneof_case_[0] = kVisible;
}
inline void Response::clear_visible() {
  if (_internal_has_visible()) {
    payload_.visible_ = false;
    clear_has_payload();
  }
}
inline bool Response::_internal_visible() const {
  if (_internal_has_visible()) {
    return payload_.visible_;
  }
  return false;
}
inline void Response::_internal_set_visible(bool value) {
  if (!_internal_has_visible()) {
    clear_payload();
    set_has_visible();
  }
  payload_.visible_ = value;
}
inline bool Response::visible() const {
  // @@protoc_insertion_point(field_get:action.Response.visible)
  return _internal_visible();
}
inline void Response::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:action.Response.visible)
}

// bytes data = 5;
inline bool Response::_internal_has_data() const {
  return payload_case() == kData;
}
inline bool Response::has_data() const {
  return _internal_has_data();
}
inline void Response::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void Response::clear_data() {
  if (_internal_has_data()) {
    payload_.data_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_payload();
  }
}
inline const std::string& Response::data() const {
  // @@protoc_insertion_point(field_get:action.Response.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline void Response::set_data(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Response.data)
}
inline std::string* Response::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:action.Response.data)
  return _s;
}
inline const std::string& Response::_internal_data() const {
  if (_internal_has_data()) {
    return payload_.data_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Response::_internal_set_data(const std::string& value) {
  if (!_internal_has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_payload();
    set_has_data();
    payload_.data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return payload_.data_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Response::release_data() {
  // @@protoc_insertion_point(field_release:action.Response.data)
  if (_internal_has_data()) {
    clear_has_payload();
    return payload_.data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Response::set_allocated_data(std::string* data) {
  if (has_payload()) {
    clear_payload();
  }
  if (data != nullptr) {
    set_has_data();
    payload_.data_.UnsafeSetDefault(data);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(data);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:action.Response.data)
}

// string value = 6;
inline bool Response::_internal_has_value() const {
  return payload_case() == kValue;
}
inline bool Response::has_value() const {
  return _internal_has_value();
}
inline void Response::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void Response::clear_value() {
  if (_internal_has_value()) {
    payload_.value_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_payload();
  }
}
inline const std::string& Response::value() const {
  // @@protoc_insertion_point(field_get:action.Response.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline void Response::set_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_value()) {
    clear_payload();
    set_has_value();
    payload_.value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:action.Response.value)
}
inline std::string* Response::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:action.Response.value)
  return _s;
}
inline const std::string& Response::_internal_value() const {
  if (_internal_has_value()) {
    return payload_.value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Response::_internal_set_value(const std::string& value) {
  if (!_internal_has_value()) {
    clear_payload();
    set_has_value();
    payload_.value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  payload_.value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Response::_internal_mutable_value() {
  if (!_internal_has_value()) {
    clear_payload();
    set_has_value();
    payload_.value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return payload_.value_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Response::release_value() {
  // @@protoc_insertion_point(field_release:action.Response.value)
  if (_internal_has_value()) {
    clear_has_payload();
    return payload_.value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Response::set_allocated_value(std::string* value) {
  if (has_payload()) {
    clear_payload();
  }
  if (value != nullptr) {
    set_has_value();
    payload_.value_.UnsafeSetDefault(value);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(value);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:action.Response.value)
}

// .action.Screenshot screenshot = 7;
inline bool Response::_internal_has_screenshot() const {
  return payload_case() == kScreenshot;
}
inline bool Response::has_screenshot() const {
  return _internal_has_screenshot();
}
inline void Response::set_has_screenshot() {
  _oneof_case_[0] = kScreenshot;
}
inline void Response::clear_screenshot() {
  if (_internal_has_screenshot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.screenshot_;
    }
    clear_has_payload();
  }
}
inline ::action::Screenshot* Response::release_screenshot() {
  // @@protoc_insertion_point(field_release:action.Response.screenshot)
  if (_internal_has_screenshot()) {
    clear_has_payload();
      ::action::Screenshot* temp = payload_.screenshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.screenshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::Screenshot& Response::_internal_screenshot() const {
  return _internal_has_screenshot()
      ? *payload_.screenshot_
      : reinterpret_cast< ::action::Screenshot&>(::action::_Screenshot_default_instance_);
}
inline const ::action::Screenshot& Response::screenshot() const {
  // @@protoc_insertion_point(field_get:action.Response.screenshot)
  return _internal_screenshot();
}
inline ::action::Screenshot* Response::unsafe_arena_release_screenshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Response.screenshot)
  if (_internal_has_screenshot()) {
    clear_has_payload();
    ::action::Screenshot* temp = payload_.screenshot_;
    payload_.screenshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_screenshot(::action::Screenshot* screenshot) {
  clear_payload();
  if (screenshot) {
    set_has_screenshot();
    payload_.screenshot_ = screenshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Response.screenshot)
}
inline ::action::Screenshot* Response::_internal_mutable_screenshot() {
  if (!_internal_has_screenshot()) {
    clear_payload();
    set_has_screenshot();
    payload_.screenshot_ = CreateMaybeMessage< ::action::Screenshot >(GetArenaForAllocation());
  }
  return payload_.screenshot_;
}
inline ::action::Screenshot* Response::mutable_screenshot() {
  ::action::Screenshot* _msg = _internal_mutable_screenshot();
  // @@protoc_insertion_point(field_mutable:action.Response.screenshot)
  return _msg;
}

// .action.Connect connect = 8;
inline bool Response::_internal_has_connect() const {
  return payload_case() == kConnect;
}
inline bool Response::has_connect() const {
  return _internal_has_connect();
}
inline void Response::set_has_connect() {
  _oneof_case_[0] = kConnect;
}
inline void Response::clear_connect() {
  if (_internal_has_connect()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.connect_;
    }
    clear_has_payload();
  }
}
inline ::action::Connect* Response::release_connect() {
  // @@protoc_insertion_point(field_release:action.Response.connect)
  if (_internal_has_connect()) {
    clear_has_payload();
      ::action::Connect* temp = payload_.connect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::Connect& Response::_internal_connect() const {
  return _internal_has_connect()
      ? *payload_.connect_
      : reinterpret_cast< ::action::Connect&>(::action::_Connect_default_instance_);
}
inline const ::action::Connect& Response::connect() const {
  // @@protoc_insertion_point(field_get:action.Response.connect)
  return _internal_connect();
}
inline ::action::Connect* Response::unsafe_arena_release_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Response.connect)
  if (_internal_has_connect()) {
    clear_has_payload();
    ::action::Connect* temp = payload_.connect_;
    payload_.connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_connect(::action::Connect* connect) {
  clear_payload();
  if (connect) {
    set_has_connect();
    payload_.connect_ = connect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Response.connect)
}
inline ::action::Connect* Response::_internal_mutable_connect() {
  if (!_internal_has_connect()) {
    clear_payload();
    set_has_connect();
    payload_.connect_ = CreateMaybeMessage< ::action::Connect >(GetArenaForAllocation());
  }
  return payload_.connect_;
}
inline ::action::Connect* Response::mutable_connect() {
  ::action::Connect* _msg = _internal_mutable_connect();
  // @@protoc_insertion_point(field_mutable:action.Response.connect)
  return _msg;
}

// .action.Tests tests = 9;
inline bool Response::_internal_has_tests() const {
  return payload_case() == kTests;
}
inline bool Response::has_tests() const {
  return _internal_has_tests();
}
inline void Response::set_has_tests() {
  _oneof_case_[0] = kTests;
}
inline void Response::clear_tests() {
  if (_internal_has_tests()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.tests_;
    }
    clear_has_payload();
  }
}
inline ::action::Tests* Response::release_tests() {
  // @@protoc_insertion_point(field_release:action.Response.tests)
  if (_internal_has_tests()) {
    clear_has_payload();
      ::action::Tests* temp = payload_.tests_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.tests_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::Tests& Response::_internal_tests() const {
  return _internal_has_tests()
      ? *payload_.tests_
      : reinterpret_cast< ::action::Tests&>(::action::_Tests_default_instance_);
}
inline const ::action::Tests& Response::tests() const {
  // @@protoc_insertion_point(field_get:action.Response.tests)
  return _internal_tests();
}
inline ::action::Tests* Response::unsafe_arena_release_tests() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Response.tests)
  if (_internal_has_tests()) {
    clear_has_payload();
    ::action::Tests* temp = payload_.tests_;
    payload_.tests_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_tests(::action::Tests* tests) {
  clear_payload();
  if (tests) {
    set_has_tests();
    payload_.tests_ = tests;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Response.tests)
}
inline ::action::Tests* Response::_internal_mutable_tests() {
  if (!_internal_has_tests()) {
    clear_payload();
    set_has_tests();
    payload_.tests_ = CreateMaybeMessage< ::action::Tests >(GetArenaForAllocation());
  }
  return payload_.tests_;
}
inline ::action::Tests* Response::mutable_tests() {
  ::action::Tests* _msg = _internal_mutable_tests();
  // @@protoc_insertion_point(field_mutable:action.Response.tests)
  return _msg;
}

// .action.LogData log = 10;
inline bool Response::_internal_has_log() const {
  return payload_case() == kLog;
}
inline bool Response::has_log() const {
  return _internal_has_log();
}
inline void Response::set_has_log() {
  _oneof_case_[0] = kLog;
}
inline void Response::clear_log() {
  if (_internal_has_log()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.log_;
    }
    clear_has_payload();
  }
}
inline ::action::LogData* Response::release_log() {
  // @@protoc_insertion_point(field_release:action.Response.log)
  if (_internal_has_log()) {
    clear_has_payload();
      ::action::LogData* temp = payload_.log_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::LogData& Response::_internal_log() const {
  return _internal_has_log()
      ? *payload_.log_
      : reinterpret_cast< ::action::LogData&>(::action::_LogData_default_instance_);
}
inline const ::action::LogData& Response::log() const {
  // @@protoc_insertion_point(field_get:action.Response.log)
  return _internal_log();
}
inline ::action::LogData* Response::unsafe_arena_release_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Response.log)
  if (_internal_has_log()) {
    clear_has_payload();
    ::action::LogData* temp = payload_.log_;
    payload_.log_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_log(::action::LogData* log) {
  clear_payload();
  if (log) {
    set_has_log();
    payload_.log_ = log;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Response.log)
}
inline ::action::LogData* Response::_internal_mutable_log() {
  if (!_internal_has_log()) {
    clear_payload();
    set_has_log();
    payload_.log_ = CreateMaybeMessage< ::action::LogData >(GetArenaForAllocation());
  }
  return payload_.log_;
}
inline ::action::LogData* Response::mutable_log() {
  ::action::LogData* _msg = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:action.Response.log)
  return _msg;
}

// .action.TestDetails testDetails = 11;
inline bool Response::_internal_has_testdetails() const {
  return payload_case() == kTestDetails;
}
inline bool Response::has_testdetails() const {
  return _internal_has_testdetails();
}
inline void Response::set_has_testdetails() {
  _oneof_case_[0] = kTestDetails;
}
inline void Response::clear_testdetails() {
  if (_internal_has_testdetails()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.testdetails_;
    }
    clear_has_payload();
  }
}
inline ::action::TestDetails* Response::release_testdetails() {
  // @@protoc_insertion_point(field_release:action.Response.testDetails)
  if (_internal_has_testdetails()) {
    clear_has_payload();
      ::action::TestDetails* temp = payload_.testdetails_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.testdetails_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::TestDetails& Response::_internal_testdetails() const {
  return _internal_has_testdetails()
      ? *payload_.testdetails_
      : reinterpret_cast< ::action::TestDetails&>(::action::_TestDetails_default_instance_);
}
inline const ::action::TestDetails& Response::testdetails() const {
  // @@protoc_insertion_point(field_get:action.Response.testDetails)
  return _internal_testdetails();
}
inline ::action::TestDetails* Response::unsafe_arena_release_testdetails() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Response.testDetails)
  if (_internal_has_testdetails()) {
    clear_has_payload();
    ::action::TestDetails* temp = payload_.testdetails_;
    payload_.testdetails_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_testdetails(::action::TestDetails* testdetails) {
  clear_payload();
  if (testdetails) {
    set_has_testdetails();
    payload_.testdetails_ = testdetails;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Response.testDetails)
}
inline ::action::TestDetails* Response::_internal_mutable_testdetails() {
  if (!_internal_has_testdetails()) {
    clear_payload();
    set_has_testdetails();
    payload_.testdetails_ = CreateMaybeMessage< ::action::TestDetails >(GetArenaForAllocation());
  }
  return payload_.testdetails_;
}
inline ::action::TestDetails* Response::mutable_testdetails() {
  ::action::TestDetails* _msg = _internal_mutable_testdetails();
  // @@protoc_insertion_point(field_mutable:action.Response.testDetails)
  return _msg;
}

// .action.PerformanceData performance = 12;
inline bool Response::_internal_has_performance() const {
  return payload_case() == kPerformance;
}
inline bool Response::has_performance() const {
  return _internal_has_performance();
}
inline void Response::set_has_performance() {
  _oneof_case_[0] = kPerformance;
}
inline void Response::clear_performance() {
  if (_internal_has_performance()) {
    if (GetArenaForAllocation() == nullptr) {
      delete payload_.performance_;
    }
    clear_has_payload();
  }
}
inline ::action::PerformanceData* Response::release_performance() {
  // @@protoc_insertion_point(field_release:action.Response.performance)
  if (_internal_has_performance()) {
    clear_has_payload();
      ::action::PerformanceData* temp = payload_.performance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    payload_.performance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::action::PerformanceData& Response::_internal_performance() const {
  return _internal_has_performance()
      ? *payload_.performance_
      : reinterpret_cast< ::action::PerformanceData&>(::action::_PerformanceData_default_instance_);
}
inline const ::action::PerformanceData& Response::performance() const {
  // @@protoc_insertion_point(field_get:action.Response.performance)
  return _internal_performance();
}
inline ::action::PerformanceData* Response::unsafe_arena_release_performance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:action.Response.performance)
  if (_internal_has_performance()) {
    clear_has_payload();
    ::action::PerformanceData* temp = payload_.performance_;
    payload_.performance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_performance(::action::PerformanceData* performance) {
  clear_payload();
  if (performance) {
    set_has_performance();
    payload_.performance_ = performance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:action.Response.performance)
}
inline ::action::PerformanceData* Response::_internal_mutable_performance() {
  if (!_internal_has_performance()) {
    clear_payload();
    set_has_performance();
    payload_.performance_ = CreateMaybeMessage< ::action::PerformanceData >(GetArenaForAllocation());
  }
  return payload_.performance_;
}
inline ::action::PerformanceData* Response::mutable_performance() {
  ::action::PerformanceData* _msg = _internal_mutable_performance();
  // @@protoc_insertion_point(field_mutable:action.Response.performance)
  return _msg;
}

inline bool Response::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Response::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Response::PayloadCase Response::payload_case() const {
  return Response::PayloadCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace action

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::action::DeviceInteractionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::action::DeviceInteractionType>() {
  return ::action::DeviceInteractionType_descriptor();
}
template <> struct is_proto_enum< ::action::ActionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::action::ActionType>() {
  return ::action::ActionType_descriptor();
}
template <> struct is_proto_enum< ::action::LogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::action::LogType>() {
  return ::action::LogType_descriptor();
}
template <> struct is_proto_enum< ::action::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::action::LogLevel>() {
  return ::action::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::action::ContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::action::ContentType>() {
  return ::action::ContentType_descriptor();
}
template <> struct is_proto_enum< ::action::AppType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::action::AppType>() {
  return ::action::AppType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_action_2eproto
